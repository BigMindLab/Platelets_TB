---
title: "Differential Expression Analysis for Platelets in TB infection"
author: "Daniel Guevara"
date: "2024-05-29"
output: html_document
---

# 1. Set up

## Call required libraries

```{r, message = FALSE}
library("stats", quietly = T)
library("SummarizedExperiment", quietly = T)
library("PADOG", quietly = T)
library("knitr", quietly = T)
library("tidyr", quietly = T)
library("dplyr", quietly = T)
library("openxlsx", quietly = T)
library("tximport", quietly = T)
library("ensembldb", quietly = T)
library("GenomicFeatures", quietly = T)
library("RColorBrewer", quietly = T)
library("gplots", quietly = T)
library("ggplot2", quietly = T)
library("ggrepel", quietly = T)
library("tsne", quietly = T)
library("umap", quietly = T)
library("MatrixGenerics", quietly = T)
library("DESeq2", quietly = T)
library("BatchJobs", quietly = T)
library("BiocParallel", quietly = T)
library("biomaRt", quietly = T)
library("pheatmap", quietly = T)
library("randomcoloR", quietly = T)
library("plotly", quietly = T)
library("svglite", quietly = T)
library("VennDiagram", quietly = T)
library("pheatmap", quietly = T)
library("ggsignif", quietly = T)
library("gridExtra", quietly = T)
library("cowplot", quietly = T)
library("gtable", quietly = T)
library("beeswarm", quietly = T)
library("ggbeeswarm", quietly = T)
library("scales", quietly = T)
library("clusterProfiler", quietly = T)
library("org.Hs.eg.db", quietly = T)
library("AnnotationDbi", quietly = T)
library("DOSE", quietly = T)
#remotes::install_github("danoguevara/OmicsKit", ref = "new-functions", force = T)
library("OmicsKit")
library("reshape2")
```

## Set working directory

```{r}
require(knitr)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "./")
sample_data <- "sample_data.xlsx"
counts_dir <- "./Counts_Salmon"
```

# 2. Pre processing workflow

## Sample metadata

```{r}
sampledata <- data.frame(read.xlsx(sample_data))

# Manage numeric variables
#sampledata <- sampledata %>%
#  mutate(
#    bmi = ifelse(is.na(bmi), median(bmi, na.rm = TRUE), bmi),
#    HR = ifelse(is.na(HR), median(HR, na.rm = TRUE), HR),
#    weight = ifelse(is.na(weight), median(weight, na.rm = TRUE), weight),
#    waist = ifelse(is.na(waist), median(waist, na.rm = TRUE), waist),
#    hip_circ = ifelse(is.na(hip_circ), median(hip_circ, na.rm = TRUE), hip_circ)
#  )

# Convert factors
sampledata <- sampledata %>%
  mutate(
    sex = factor(sex),
    latent_TB = factor(latent_TB, levels = c(0, 1)),
    age_cat = factor(age_cat, ordered = T, levels = c("20s", "30s", "40s", "50s", "60s")),
    group = factor(group, levels = c("Control", "TB")),
    #HR_cat = factor(HR_cat, levels = c("60s", "70s", "80s", "90s", "100s", "110s", "140s")),
    #weight_cat = factor(weight_cat, levels = c("40s", "50s", "60s", "70s", "80s", "90s")),
    #height_cat = factor(height_cat, levels = c(140, 150, 160, 170, 180))
  )

rownames(sampledata) <- sampledata$id
sampledata <- sampledata[, c("id", "num", "group", "latent_TB", "sex", "age", "age_cat",
                             "height","appetite", "depression", "RIN_ours", "RIN_Ed")]

# Normal sample clustered with TB patients
sampledata <- sampledata[-11, ]
```

## Managing Salmon count files

```{r}
count_files <- file.path(counts_dir, paste0(sampledata$id, "_quant.sf"))
names(count_files) <- sampledata$id

txi <- tximport(count_files, type="salmon", txOut=TRUE, countsFromAbundance="no")
counts.tx <- txi$counts
counts.tx <- counts.tx[rowSums(counts.tx) > 0,]

sampledata$tx_counts <- colSums(counts.tx)

# Output
# write.xlsx(sampledata, file = "samples_with_counts.xlsx", colNames = T, rowNames = F, append = F)
```

### Counts per sample

```{r}
my_colors <- c("#bbffff", "#ffb6c1")

p.counts <- ggplot(data = sampledata, aes(x = id, y = tx_counts, fill = group)) +
  theme_bw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank()) +
  geom_bar(stat="identity", color="black", linewidth = 0.3) + scale_fill_manual(values = my_colors) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_y_continuous(expand = expansion(mult = c(0, .01)), labels = scales::comma, breaks = seq(0,7e+7,by=0.5e+7)) +
  xlab("Sample ID") + ylab("Counts") + theme(axis.title=element_text(size=16))

p.counts

# ggsave("plots/Counts-Transcript_per_Sample.jpg", p.counts, width = 10, height = 8, dpi = 300)
```

## Transcripts into genes

```{r}
#tx2gene <- data.frame(read.xlsx("tx2gene_GRCh38v112.xlsx"))
txi.toGene <- summarizeToGene(txi, tx2gene[, c("transcriptID","geneID")])

# Add gene counts
counts.gene <- as.data.frame(txi.toGene$counts)
counts.gene <- counts.gene[rowSums(counts.gene) > 0,]
sampledata$gene_counts <- colSums(counts.gene)

# write.xlsx(sampledata, file = "samples_with_counts.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)

# Load geneID annotations
annotations <- c("symbol", "biotype", "chromosome", "gene_start", "gene_end", "gene_length", "description")
geneID.details <- tx2gene[,c("geneID", annotations)]
geneID.details <- geneID.details[!duplicated(geneID.details), ]

#######################
## Extra genes
### Remove NAs
for (i in 1:nrow(geneID.details)) {
  if (is.na(geneID.details$symbol[i]) | geneID.details$symbol[i] == "") {
    geneID.details$symbol[i] <- geneID.details$geneID[i]
  }
}
sum(is.na(geneID.details$symbol))
sum(geneID.details$symbol == "")
#######################

# Add annotations
counts.gene_annotations <- counts.gene
counts.gene_annotations$geneID <- rownames(counts.gene_annotations)
counts.gene_annotations <- OmicsKit::add_annotations(object = counts.gene_annotations,
                                                     reference = geneID.details,
                                                     variables = annotations)

# write.xlsx(counts.gene_annotations, file = "Raw_Gene_Counts_Annotated.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)
```

### [RUN ONCE] Create leukocytes genes blacklist

```{r}
#library("readxl")
#blacklist_allLeuko <- data.frame(read_xls("Palmer_2006_Leuko_genes.xls"))

# Remove unknown genes
#blacklist_allLeuko <- blacklist_allLeuko %>% filter(!grepl("^IMAGE:", symbol))

# Retrieve database version 112
#mart <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", host = "https://may2024.archive.ensembl.org")

# Ensembl IDs from the gene symbols
#ensembl_data <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
#                      filters = "external_gene_name",
#                      values = unique(blacklist_allLeuko$symbol),
#                      mart = mart)

#colnames(ensembl_data) <- c("ensembl", "symbol")

# Remove obsolete ensembl IDs
#duplicated_ensembl_genes <- ensembl_data[duplicated(ensembl_data$symbol) == T, ]
#duplicated_ensembl_genes <- ensembl_data[ensembl_data$symbol %in% duplicated_ensembl_genes$symbol, ]
#duplicated_ensembl_genes <- duplicated_ensembl_genes[order(duplicated_ensembl_genes$symbol, decreasing = F), ]
#rownames(duplicated_ensembl_genes) <- 1:nrow(duplicated_ensembl_genes)
#duplicated_ensembl_genes <- duplicated_ensembl_genes[c(1,seq(9,17,2),22,seq(26,36,2),42,50,61,65,77,86,90,93,104,108,
#                                                       117,129:130,132,137,143:144,147,149,seq(151,157,2),161,163:164,
#                                                       166,168,177:178,180,seq(183,193,2),201,203,211,seq(213,221,2)), ]

# Final ensembl_data
#ensembl_data <- rbind(ensembl_data[!(ensembl_data$symbol %in% duplicated_ensembl_genes$symbol), ], duplicated_ensembl_genes)

# Merge Ensembl IDs with the original data
#blacklist_allLeuko <- blacklist_allLeuko[blacklist_allLeuko$symbol %in% ensembl_data$symbol, ]
#blacklist_allLeuko <- blacklist_allLeuko %>% left_join(ensembl_data, by = "symbol")
#blacklist_allLeuko <- blacklist_allLeuko[, c("ensembl", "symbol", "cell_type")]

# Remove ribosomal genes
#blacklist_allRibo <- data.frame(read.csv("blacklist_all-ribo.tsv", sep = "\t", header = TRUE))
#blacklist_allLeuko <- blacklist_allLeuko[!(blacklist_allLeuko$ensembl %in% blacklist_allRibo$Gene), ]

#write.table(x = blacklist_allLeuko, file = "blacklist_all-Leuko.tsv", sep = "\t", col.names = T, row.names = F)
```

## Filter out blacklists

```{r}
blacklist_nRibo <- data.frame(read.csv("blacklist_nuclear-ribo.tsv", sep = "\t", header = TRUE))
blacklist_mtRibo <- data.frame(read.csv("blacklist_mito-ribo.tsv", sep = "\t", header = TRUE))
blacklist_allRibo <- data.frame(read.csv("blacklist_all-ribo.tsv", sep = "\t", header = TRUE))
blacklist_allLeuko <- data.frame(read.csv("blacklist_all-Leuko.tsv", sep = "\t", header = TRUE))

# Keep the genes in each blacklist
genecounts.nRibo <- counts.gene[rownames(counts.gene) %in% blacklist_nRibo[,1], ]
genecounts.mtRibo <- counts.gene[rownames(counts.gene) %in% blacklist_mtRibo[,1], ]
genecounts.leuko <- counts.gene[rownames(counts.gene) %in% blacklist_allLeuko[,1], ]
genecounts.filtered <- counts.gene[!(rownames(counts.gene) %in% c(blacklist_allRibo[,1], blacklist_allLeuko[,1])), ]

sampledata$Counts_nRibo <- colSums(genecounts.nRibo)
sampledata$Counts_mtRibo <- colSums(genecounts.mtRibo)
sampledata$Counts_leuko <- colSums(genecounts.leuko)
sampledata$Counts_filtered <- colSums(genecounts.filtered)

# write.xlsx(sampledata, file = "samples_with_counts.xlsx", colNames = T, rowNames = F, append = F)

# Filter the txi object
#keep <- !(rownames(txi.toGene$counts) %in% c(blacklist_allRibo[,1], blacklist_allLeuko[,1]))
keep <- !(rownames(txi.toGene$counts) %in% blacklist_allRibo[,1])

txi.toGene$abundance <- txi.toGene$abundance[keep, ]
txi.toGene$counts <- txi.toGene$counts[keep, ]
txi.toGene$length <- txi.toGene$length[keep, ]
```

### Counts per blacklist

```{r}
for (bl in c("Counts_nRibo", "Counts_mtRibo", "Counts_leuko")) {
  p.sub <- ggplot(data = sampledata, aes(x = factor(id, levels = id), y = .data[[bl]], fill = group)) +
    theme_bw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank()) +
    geom_bar(stat="identity", color="black", linewidth = 0.3) + scale_fill_manual(values = my_colors) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), strip.text = element_text(size = 14)) +
    scale_y_continuous(expand = expansion(mult = c(0, .01)), labels = scales::comma) +
    xlab("Sample ID") + ylab(unlist(strsplit(bl, split = "_"))[2]) + theme(axis.title=element_text(size=16))
  
  print(p.sub)
  
  ggsave(paste0("plots/Counts-Transcript_per_Sample_", unlist(strsplit(bl, split = "_"))[2], ".jpg"),
         p.sub, width = 10, height = 8, dpi = 300)
}

# Filtered
p.filt <- ggplot(data = sampledata, aes(x = factor(id, levels = id), y = Counts_filtered, fill = group)) +
  theme_bw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank()) +
  geom_bar(stat="identity", color="black", linewidth = 0.3) +
  scale_fill_manual(values = my_colors) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), strip.text = element_text(size = 14)) +
  scale_y_continuous(expand = expansion(mult = c(0, .05)), labels = scales::comma, breaks = seq(0,7e+7,by=0.5e+7)) +
  xlab("Sample ID") + ylab("Filtered") + theme(axis.title=element_text(size=16))

p.filt

ggsave("plots/Counts-Transcript_per_Sample_filtered.jpg", p.filt,
       width = 10, height = 8, dpi = 300)
```

## Scaled TPMs

```{r}
# Calculate the TPM. The columns will now add 1 million.
gene.tpm <- tpm(counts.gene, counts.gene_annotations$gene_length)
gene.tpm <- data.frame(gene.tpm)
gene.tpm.annotated <- OmicsKit::add_annotations(gene.tpm, geneID.details, variables = annotations)
# write.xlsx(gene.tpm.annotated, file = "Gene_Counts_TPM.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)

# Keep the genes in each blacklist
geneTPM.nRibo <- gene.tpm[rownames(gene.tpm) %in% blacklist_nRibo[,1], ]
geneTPM.mtRibo <- gene.tpm[rownames(gene.tpm) %in% blacklist_mtRibo[,1], ]
geneTPM.leuko <- gene.tpm[rownames(gene.tpm) %in% unique(blacklist_allLeuko[,1]),]
geneTPM.filtered <- gene.tpm[!(rownames(gene.tpm) %in% c(blacklist_allRibo[,1], blacklist_allLeuko[,1])), ]

sampledata$TPM_nRibo <- colSums(geneTPM.nRibo[1:(length(geneTPM.nRibo))])
sampledata$TPM_mtRibo <- colSums(geneTPM.mtRibo[1:(length(geneTPM.nRibo))])
sampledata$TPM_leuko <- colSums(geneTPM.leuko[1:(length(geneTPM.nRibo))])
sampledata$TPM_filtered <- colSums(geneTPM.filtered[1:(length(geneTPM.nRibo))])

#write.xlsx(sampledata, file = "samples_with_counts.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)
```

### Plot the TPMs per list

```{r}
# Plot the TPMs per list STACKED
subgroups <- c("TPM_nRibo", "TPM_mtRibo", "TPM_leuko", "TPM_filtered")
sampledata_TPMlong <- reshape(sampledata[, c("id", subgroups)], varying = subgroups, direction = "long", sep = "_")
#sampledata_TPMlong <- reshape(sampledata[sampledata$group == "Control", c("id", subgroups)],varying = subgroups, direction = "long", sep = "_")

sampledata_TPMlong <- sampledata_TPMlong %>%
  mutate(group = case_when(id %in% sampledata$id[sampledata$group == "Control"] ~ "Control",
                           TRUE ~ "TB")) %>%
  mutate(group = factor(group, levels = c("Control", "TB"), ordered = TRUE))

names(sampledata_TPMlong)[names(sampledata_TPMlong) == "time"] <- "Gene_Type"
sampledata_TPMlong$Gene_Type <- factor(sampledata_TPMlong$Gene_Type, levels = c("nRibo", "mtRibo", "leuko", "filtered"))

bl.colors <- c("coral1", "gold", "peru", "azure")

p.TPMs <- ggplot(data = sampledata_TPMlong, aes(x = factor(id, levels = sampledata$id), y = TPM, fill = Gene_Type)) +
  theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank(), axis.title = element_text(size=15),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=7), strip.text = element_text(size = 14)) +
  geom_bar(position="stack", stat="identity", color="black", linewidth = 0.1) + scale_fill_manual(values = bl.colors) +
  xlab("Sample ID") + ylab("TPM") +
  scale_y_continuous(expand = expansion(mult = c(0, .01)), breaks = seq(0, 1e+6, by = 25e+4), labels = scales::comma)

p.TPMs

ggsave("plots/TPMs-Transcript_per_Sample_subgroups.jpg", p.TPMs, width = 10, height = 8, dpi = 300)
#ggsave("plots/TPMs-Transcript_per_Sample_subgroups_Control.jpg", p.TPMs, width = 8, height = 8, dpi = 300)

# Plot the TPMs per list INDIVIDUALLY
for (bl in subgroups) {
  p.sub <- ggplot(data = sampledata, aes(x = factor(id, levels = id), y = .data[[bl]], fill = group)) +
    theme_bw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank()) +
    geom_bar(stat="identity", color="black", linewidth = 0.1) + scale_fill_manual(values = my_colors) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
          strip.text = element_text(size = 14), axis.title = element_text(size=16)) +
    scale_y_continuous(expand = expansion(mult = c(0, .01)), labels = scales::comma) +
    xlab("Sample ID") + ylab(unlist(strsplit(bl, split = "_"))[2])
  
  print(p.sub)
  
  ggsave(paste0("plots/TPMs-Transcript_per_Sample_", unlist(strsplit(bl, split = "_"))[2], ".jpg"), p.sub, width = 10, height = 8, dpi = 300)
  #ggsave(paste0("plots/TPMs-Transcript_per_Sample_An_", unlist(strsplit(bl, split = "_"))[2], ".jpg"), p.sub, width = 8, height = 8, dpi = 300)
}
```

### Plot the counts per list

```{r, echo=FALSE}
# Plot the counts per list STACKED
subgroups <- c("Counts_nRibo", "Counts_mtRibo", "Counts_leuko", "Counts_filtered")
sampledata_Countslong <- reshape(sampledata[, c("id", subgroups)], varying = subgroups, direction = "long", sep = "_")
#sampledata_Countslong <- reshape(sampledata[sampledata$group == "Control", c("id", subgroups)], varying = subgroups, direction = "long", sep = "_")
sampledata_Countslong <- sampledata_Countslong %>%
  mutate(group = case_when(id %in% sampledata$id[sampledata$group == "Control"] ~ "Control",
                           TRUE ~ "TB")) %>%
  mutate(group = factor(group, levels = c("Control", "TB"), ordered = TRUE))

names(sampledata_Countslong)[names(sampledata_Countslong) == "time"] <- "Gene_Type"
sampledata_Countslong$Gene_Type <- factor(sampledata_Countslong$Gene_Type, levels = c("nRibo", "mtRibo", "leuko", "filtered"))

p.Counts <- ggplot(data = sampledata_Countslong, aes(x = factor(id, levels = sampledata$id), y = Counts, fill = Gene_Type)) +
  theme_bw() + theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank(),
                     strip.text = element_text(size = 14), axis.title = element_text(size = 16),
                     axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=7)) +
  geom_bar(position="stack", stat="identity", color="black", linewidth = 0.1) +
  scale_fill_manual(values = bl.colors) + xlab("Sample ID") +
  ylab("Counts") + scale_y_continuous(expand = expansion(mult = c(0, .01)), labels = scales::comma, breaks = seq(0,25e+7,by=1e+7))

p.Counts

ggsave("plots/Counts-Transcript_per_Sample_subgroups.jpg", p.Counts, width = 10, height = 8, dpi = 300)
#ggsave("plots/Counts-Transcript_per_Sample_subgroups_Control.jpg", p.Counts, width = 8, height = 8, dpi = 300)

# Plot the counts per list INDIVIDUALLY
for (bl in subgroups) {
  p.sub <- ggplot(data = sampledata[sampledata$group == "Control", ], aes(x = factor(id, levels = id), y = .data[[bl]], fill = group)) + theme_bw() +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_blank(), strip.text = element_text(size = 14),
          axis.title = element_text(size=15), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=7)) +
    geom_bar(stat="identity", color="black", linewidth = 0.1) + scale_fill_manual(values = my_colors) +
    scale_y_continuous(expand = expansion(mult = c(0, .01)), labels = scales::comma) +
    xlab("Sample ID") + ylab(unlist(strsplit(bl, split = "_"))[2])
  
  print(p.sub)
  
  # ggsave(paste0("plots/Counts-Transcript_per_Sample_", unlist(strsplit(bl, split = "_"))[2], ".jpg"), p.sub, width = 15, height = 8, dpi = 300)
  ggsave(paste0("plots/Counts-Transcript_per_Sample_Control_", unlist(strsplit(bl, split = "_"))[2], ".jpg"), p.sub, width = 15, height = 8, dpi = 300)
}
```

## [RUN ONCE] Create low counts genes blacklist

```{r}
#blacklist_lowCounts <- as.data.frame(read.xlsx("Normalized_Gene_counts.xlsx"))
#blacklist_lowCounts <- blacklist_lowCounts[, c("geneID", "symbol", "Mean", "Mean.C", "Mean.TB")]
#blacklist_lowCounts <- blacklist_lowCounts[blacklist_lowCounts$Mean <= 20, ]

#write.table(blacklist_lowCounts, "blacklist_low-Counts.tsv", sep = "\t", col.names = T, row.names = F)
#remove(blacklist_low_Counts)
```

# 3. Differential Expression Analysis with DESeq2

```{r}
# Filter low counts
blacklist_lowCounts <- data.frame(read.csv("blacklist_low-Counts.tsv", sep = "\t", header = TRUE))
keep <- !(rownames(txi.toGene$counts) %in% blacklist_lowCounts$geneID[blacklist_lowCounts$Mean <= 10])

txi.toGene$abundance <- txi.toGene$abundance[keep, ]
txi.toGene$counts <- txi.toGene$counts[keep, ]
txi.toGene$length <- txi.toGene$length[keep, ]

# Note: Salmon counts are going to be rounded
ds.deseq <- DESeqDataSetFromTximport(txi.toGene, sampledata, ~group)
dea_formula <- paste(attr(terms(ds.deseq@design), "term.labels"), collapse = "_")

colData(ds.deseq)$group  <- factor(colData(ds.deseq)$group,
                                   levels = c("Control", "TB"))

# Note that read quantifications are rounded in DESeq, so Salmon counts < 0.5 are now 0
nozero <- rowSums(counts(ds.deseq)) > 0
ds.deseq <- ds.deseq[nozero, ] # Remove genes with zero counts
ds.deseq <- estimateSizeFactors(ds.deseq)

######################
# Normalized gene counts
normalized.counts <- as.data.frame(counts(ds.deseq, normalized = TRUE))

TB.ids <- sampledata$id[sampledata$group == "TB"]
C.ids <- sampledata$id[sampledata$group == "Control"]

normalized.counts$Mean.TB <- rowMeans(normalized.counts[, TB.ids])
normalized.counts$Mean.C <- rowMeans(normalized.counts[, C.ids])
normalized.counts$Mean <- rowMeans(normalized.counts[, c(TB.ids, C.ids)])

# Adding gene name and description
normalized.counts.annotated <- OmicsKit::add_annotations(normalized.counts, geneID.details, variables = annotations)
#write.xlsx(normalized.counts.annotated, file = "Normalized_Gene_counts.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)
#write.xlsx(normalized.counts.annotated, file = "Normalized_Gene_counts_wo_Leuko.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)
#write.xlsx(normalized.counts.annotated, file = "Normalized_Gene_counts_wo_lowCounts.xlsx", colNames = T, rowNames = F, append = F, overwrite = T)
######################

# Variance Stabilizing Transformation
transf.data <- varianceStabilizingTransformation(ds.deseq)
```

### Explore Negative binomial

```{r}
normCounts <- normalized.counts.annotated[, c("geneID", "symbol", "Mean")]
normCounts$category <- ifelse(normCounts$Mean == 0, "= 0",
                              ifelse(normCounts$Mean <= 1, "<= 1",
                                     ifelse(normCounts$Mean <= 2, "<= 2",
                                            ifelse(normCounts$Mean <= 3, "<= 3",
                                                   ifelse(normCounts$Mean <= 5, "<= 5",
                                                          ifelse(normCounts$Mean <= 10, "<= 10",
                                                                 ifelse(normCounts$Mean <= 25, "<= 25", "> 25")))))))
normCounts$category <- factor(normCounts$category, levels = c("= 0", "<= 1", "<= 2", "<= 3", "<= 5", "<= 10", "<= 25", "> 25"))

ggplot(normCounts[normCounts$Mean <= 50, ], aes(x = Mean, fill = category)) +
  geom_histogram(binwidth = 1, color = "black", position = "stack") + theme_bw() + xlab("Mean Normalized Counts") +
  ylab("Frequency") + scale_x_continuous(breaks = seq(0, 50, by = 5)) + scale_y_continuous(breaks = seq(0, 15000, by = 2500)) +
  scale_fill_manual(values = c("= 0" = "grey70",
                               "<= 1" = "coral1",
                               "<= 2" = "gold",
                               "<= 3" = "mistyrose",
                               "<= 5" = "violet",
                               "<= 10" = "peru",
                               "<= 25" = "azure",
                               "> 25" = "steelblue"),
                    name = "Counts") +
  theme(strip.text = element_text(size = 14), axis.text = element_text(size = 12), axis.title = element_text(size = 16),
        legend.title = element_text(size = 14), legend.text = element_text(size = 12))
```


## Explore confounders

## PCA with Ward.D2 clustering

```{r}
confounding_var <- colnames(sampledata)[c(3:4, 6:12)]
confounding_name <- c("Group", "Latent TB", "Age", "Age", "Height", "Appetite", "Depression", "RIN", "RIN")


# Function
PCA_clust <- function(object, PCs = c(1,2), ntop = 200, returnData = FALSE,
                     variables = c(fill = "VarFill", shape = "VarShape"),
                     legend_names = c(fill = "Sample Type", shape = "Library"),
                     size = 7, alpha = 1, colors = NULL, shapes = NULL,
                     legend_title = 20, legend_elements = 16, legend_pos = c(0.80, 0.80, "right"),
                     labels = NULL, name_tags = NULL, cluster_data = FALSE, n_clusters = 3)

{

  # Estimate the variance in each row (gene or transcript)
  variances <- matrixStats::rowVars(assay(object))

  # Select the top variances (value passed as ntop)
  top.variances <- order(variances, decreasing = TRUE)[1:min(ntop, length(variances))]

  # Extract data for clustering if `cluster_data` is TRUE
  if (cluster_data) {
    # Apply hierarchical clustering with Ward.D2 method
    hc <- hclust(dist(t(assay(object)[top.variances, ])), method = "ward.D2")
    
    # Create cluster labels based on `n_clusters`
    cluster_labels <- cutree(hc, k = n_clusters)
    
    # Add cluster labels to colData
    colData(object)$Cluster <- as.factor(cluster_labels)
  }

  # Principal Component Analysis
  pca <- stats::prcomp(t(assay(object)[top.variances, ]))

  # Calculate the percent of variance per component
  percentVar <- pca$sdev ^ 2 / sum(pca$sdev ^ 2)

  if (!all(variables %in% names(colData(object)))) {
    stop("The variable names should be columns of the DESeq2 dataset, examine: colData(object)")
  }

  # Prepare a data frame with the PCs to plot and the metadata variable selected
  d <- data.frame(PCx = pca$x[, PCs[1]], PCy = pca$x[, PCs[2]],
                  colData(object)[, variables, drop = FALSE])
  
  # Add the cluster variable to the data if clustering was performed
  if (cluster_data) {
    d$Cluster <- colData(object)$Cluster
  }

  if (length(variables) == 2) {

    if (is.numeric(d[[variables[1]]])) {
        # If the variable is numeric, use a gradient scale
        p.nicePCA <- ggplot(data = d, aes(x = PCx, y = PCy, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
          geom_point(size = size, alpha = alpha) +
          scale_shape_manual(values = shapes) +
          scale_fill_gradient(low = "white", high = "red") +
          labs(fill = legend_names[1], shape = legend_names[2])
    } else {
        # If the variable is categorical, use manual scale
        p.nicePCA <- ggplot(data = d, aes(x = PCx, y = PCy, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
          geom_point(size = size, alpha = alpha) +
          scale_shape_manual(values = shapes) +
          scale_fill_manual(values = colors, guide = guide_legend(override.aes = aes(shape = 21))) +
          labs(fill = legend_names[1], shape = legend_names[2])
    }

  } else if (length(variables) == 1) {

    if (is.numeric(d[[variables]])) {
        # For numeric variable
        p.nicePCA <- ggplot(data = d, aes(x = PCx, y = PCy, fill = .data[[variables]])) +
          geom_point(size = size, alpha = alpha, shape = 21) +
          scale_fill_gradient(low = "white", high = "red") +
          labs(fill = legend_names)
    } else {
        # For categorical variable
        p.nicePCA <- ggplot(data = d, aes(x = PCx, y = PCy, fill = .data[[variables]])) +
          geom_point(size = size, alpha = alpha, shape = 21) +
          scale_fill_manual(values = colors, guide = guide_legend(override.aes = aes(shape = 21))) +
          labs(fill = legend_names)
    }
  }

  p.nicePCA <- p.nicePCA + coord_fixed() + theme_bw() +
    theme(legend.title = element_text(size = legend_title, face = "bold"),
          legend.text = element_text(size = legend_elements),
          #legend.background = element_rect(color = "black"),
          legend.position = c(legend_pos[1], legend_pos[2]),
          legend.box.just = legend_pos[3],
          axis.title = element_text(size = 16),
          axis.text = element_text(size = 12)) +
    xlab(paste0("PC", PCs[1], ": ", round(percentVar[PCs[1]] * 100), "% variance")) +
    ylab(paste0("PC", PCs[2], ": ", round(percentVar[PCs[2]] * 100), "% variance"))

  if (is.null(labels) == FALSE) {

    # Add the column of labels to the data frame
    d <- data.frame(d, colData(object)[,c(labels[1]), drop = FALSE])

    # Add the labels to the plot
    p.nicePCA <- p.nicePCA +
      geom_text(aes(label = d[,labels[1]]),
                color = "black", size = as.numeric(labels[2]))
  }

  if (is.null(name_tags) == FALSE) {

    if (!requireNamespace("ggrepel", quietly = TRUE)) {
      stop(
        "Package \"ggrepel\" must be installed to use this function.",
        call. = FALSE
        )
    }

    # Add the column of name tags to the data frame
    d <- data.frame(d, colData(object)[,c(name_tags[1]), drop = FALSE])

    # Add the name tags to the plot
    p.nicePCA <- p.nicePCA +
      ggrepel::geom_text_repel(aes(label = d[,name_tags[1]]),
                               color = "black", cex = as.numeric(name_tags[2]),
                               min.segment.length = unit(as.numeric(name_tags[3]), "lines"),
                               box.padding = unit(as.numeric(name_tags[4]), "lines"))
  }

  if (returnData) {
    attr(d, "percentVar") <- percentVar[PCs[1]:PCs[2]]
    return(d)
  }

  return(p.nicePCA)
}

for (i in seq_along(confounding_var)) {
  pca12_clust <- PCA_clust(
    transf.data, PCs = c(1, 2),
    ntop =  nrow(assay(transf.data)),
    variables = c(confounding_var[i], "sex"),
    legend_names = c(confounding_name[i], "Sex"),
    colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"),
    shapes = 21:22,
    legend_title = 15,
    legend_elements = 14,
    legend_pos = NULL,
    labels = NULL
  )
  
  #print(pca12_clust)
  
  #ggsave(filename = paste0("plots/dim_reduction/PCA/PCA12_", confounding_var[i], "_wo_Leuko.jpg"),
  #       plot = pca12_clust, width = 9, height = 6, dpi = 300)
  ggsave(filename = paste0("plots/dim_reduction/PCA/PCA12_", confounding_var[i], "_wo_lowCounts.jpg"),
         plot = pca12_clust, width = 9, height = 6, dpi = 300)
}

# Clustering
#pca12_clust <- PCA_clust(transf.data, PCs = c(1, 2), ntop =  nrow(assay(transf.data)),
#                         variables = c("Cluster", "sex"), legend_names = c("Cluster", "Sex"),
#                         colors = c(my_colors, "#dda0dd", "#ffa07a"), shapes = 21:22, legend_title = 15, legend_elements = 14,
#                         legend_pos = NULL, labels = NULL, cluster_data = TRUE, n_clusters = 3)
#pca12_clust

#ggsave(filename = paste0("plots/dim_reduction/PCA/PCA12_cluster_n", 3, ".jpg"),
#       plot = pca12_clust, width = 9, height = 6, dpi = 300)

# Without sample 11
#pca12_clust <- PCA_clust(transf.data[, colnames(transf.data) != "301-1"], PCs = c(1, 2),
#                         ntop =  nrow(assay(transf.data[, colnames(transf.data) != "301-1"])),
#                         variables = c("group", "sex"), legend_names = c("Group", "Sex"),
#                         colors = c(my_colors), shapes = 21:22, legend_title = 15,
#                         legend_elements = 14, legend_pos = NULL, labels = NULL)
#pca12_clust

#ggsave(filename = paste0("plots/dim_reduction/PCA/PCA12_group_wo_", 11, ".jpg"),
#       plot = pca12_clust, width = 9, height = 6, dpi = 300)
```

## tSNE with HDBSCAN clustering

```{r}
iter <- 10000
seed <- 0
plex <- 3

# Function
tSNE_clust <- function(object, seed = 0, perplexity = 3, max_iterations = 10000, returnData = FALSE,
                       variables = c(fill = "VarFill", shape = "VarShape"),
                       colors = NULL, shapes = NULL, size = 7, alpha = 1,
                       legend_names = c(fill = "Label Fill", shape = "Label Shape"),
                       legend_title = 20, legend_elements = 16, legend_pos = c(0.80, 0.80, "right"),
                       labels = NULL, name_tags = NULL, cluster_data = FALSE, min_points = 5)

{
  
  if (!requireNamespace("tsne", quietly = TRUE)) {
    stop(
      "Package \"tsne\" must be installed to use this function.",
      call. = FALSE
    )
  }

  set.seed(seed) # set the seed so the results can be reproducible
  
  if (cluster_data) {
    # Perform HDBSCAN clustering
    hdbscan_result <- dbscan::hdbscan(t(assay(object)), minPts = min_points)
    
    # Add cluster labels to colData
    colData(object)$Cluster <- as.factor(hdbscan_result$cluster)
  }

  # Calculate the euclidean distances between samples
  sampleDists <- stats::dist(t(assay(object)))

  samples.tsne <- tsne::tsne(sampleDists, perplexity = perplexity, max_iter = max_iterations, epoch = 1000)

  df.tsne <- cbind(data.frame(samples.tsne),
                   colData(object)[, variables, drop = FALSE])

  if (length(variables) == 2) {
    
    if (is.numeric(df.tsne[[variables[1]]])) {
      
      p.tsne <- ggplot(data = df.tsne, aes(x = X1, y = X2, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
        geom_point(size = size, alpha = alpha) + labs(fill = legend_names[1], shape = legend_names[2]) +
        scale_shape_manual(values = shapes) +
        scale_fill_gradient(low = "white", high = "red")
      
    } else {
      
      p.tsne <- ggplot(data = df.tsne, aes(x = X1, y = X2, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
        geom_point(size = size, alpha = alpha) + labs(fill = legend_names[1], shape = legend_names[2]) +
        scale_shape_manual(values = shapes) +
        scale_fill_manual(values = colors, guide = guide_legend(override.aes = list(shape = shapes[1])))
      
    }

  } else if (length(variables) == 1) {
    
    if (is.numeric(df.tsne[[variables]])) {
      
      p.tsne <- ggplot(data = df.tsne, aes(x = X1, y = X2, fill = .data[[variables]])) +
        geom_point(size = size, alpha = alpha, shape = shapes[1]) +
        scale_fill_gradient(low = "white", high = "red") +
        labs(fill = legend_names[1])
      
    } else {
      
      p.tsne <- ggplot(data = df.tsne, aes(x = X1, y = X2, fill = .data[[variables]])) +
        geom_point(size = size, alpha = alpha, shape = shapes[1]) +
        scale_fill_manual(values = colors, guide = guide_legend(override.aes = list(shape = shapes[1]))) +
        labs(fill = legend_names[1])
      
    }
  }

  p.tsne <- p.tsne + coord_fixed() + theme_bw() +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          legend.title = element_text(size = legend_title, face = "bold"),
          legend.text = element_text(size = legend_elements),
          #legend.background = element_rect(color = "black"),
          legend.position = c(legend_pos[1], legend_pos[2]),
          legend.box.just = legend_pos[3])

  if (is.null(labels) == FALSE) {

    # Add the column of labels to the data frame
    df.tsne <- data.frame(df.tsne, colData(object)[, labels[1], drop = FALSE])

    # Add the labels to the plot
    p.tsne <- p.tsne +
      geom_text(aes(label = df.tsne[,labels[1]]), color = "black", size = as.numeric(labels[2]))
  }

  if (is.null(name_tags) == FALSE) {

    if (!requireNamespace("ggrepel", quietly = TRUE)) {
      stop(
        "Package \"ggrepel\" must be installed to use this function.",
        call. = FALSE
        )
    }

    # Add the column of name tags to the data frame
    df.tsne <- data.frame(df.tsne, colData(object)[, name_tags[1], drop = FALSE])

    # Add the name tags to the plot
    p.tsne <- p.tsne +
      ggrepel::geom_text_repel(aes(label = df.tsne[,name_tags[1]]),
                               color = "black", cex = as.numeric(name_tags[2]),
                               min.segment.length = unit(as.numeric(name_tags[3]), "lines"),
                               box.padding = unit(as.numeric(name_tags[4]), "lines"))
  }

  if (returnData) {
    return(df.tsne)
  } else {
    return(p.tsne)
  } 
}


for (i in seq_along(confounding_var)) {
  tSNE_plot <- tSNE_clust(
    transf.data, seed = seed, perplexity = plex, max_iterations = iter,
    variables = c(confounding_var[i], "sex"),
    legend_names = c(confounding_name[i], "Sex"),
    colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"),
    shapes = 21:22,
    legend_title = 15,
    legend_elements = 14,
    legend_pos = NULL,
    labels = NULL
  )
  
  print(tSNE_plot)
  
  ggsave(filename = paste0("plots/dim_reduction/tSNE/tSNE_s", seed, "_p", plex, "_i", (iter/1000), "k_", confounding_var[i], ".jpg"),
         plot = tSNE_plot, width = 7, height = 6, dpi = 300)
}

# Clustering
#tSNE_plot <- tSNE_clust(transf.data, seed = seed, perplexity = plex, max_iterations = iter,
#                        variables = c("Cluster", "sex"), legend_names = c("Cluster", "Sex"),
#                        colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"), shapes = 21:22, legend_title = 15,
#                        legend_elements = 14, legend_pos = NULL, labels = NULL, cluster_data = TRUE, min_points = 6)

#tSNE_plot

# Without sample 11
#tSNE_plot <- tSNE_clust(transf.data[, colnames(transf.data) != "301-1"], seed = seed, perplexity = plex, max_iterations = iter,
#                        variables = c("group", "sex"), legend_names = c("Group", "Sex"),
#                        colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"), shapes = 21:22, legend_title = 15,
#                        legend_elements = 14, legend_pos = NULL, labels = NULL)

#tSNE_plot

#ggsave(filename = paste0("plots/dim_reduction/tSNE/tSNE_s", seed, "_p", plex, "_i", (iter/1000), "k_group_wo_", 11, ".jpg"),
#         plot = tSNE_plot, width = 7, height = 6, dpi = 300)
```

## UMAP with HDBSCAN clustering

```{r}
# Function
UMAP_clust <- function(object, neighbors = 4, components = 3, epochs = 10000, returnData = FALSE,
                       variables = c(fill = "VarFill", shape = "VarShape"),
                       colors = NULL, shapes = NULL, size = 7, alpha = 1,
                       legend_names = c(fill = "Label Fill", shape = "Label Shape"),
                       legend_title = 20, legend_elements = 16, legend_pos = c(0.80, 0.80, "right"),
                       labels = NULL, # c(var = "patient", size = 2)
                       name_tags = NULL, # c(var = "label", size = 3, minlen = 2, box = 0.5)
                       cluster_data = FALSE, min_points = 5)

{

  if (!requireNamespace("umap", quietly = TRUE)) {
    stop(
      "Package \"umap\" must be installed to use this function.",
      call. = FALSE
      )
  }
  
  if (cluster_data) {
    # Perform HDBSCAN clustering
    hdbscan_result <- dbscan::hdbscan(t(assay(object)), minPts = min_points)
    
    # Add cluster labels to colData
    colData(object)$Cluster <- as.factor(hdbscan_result$cluster)
  }
  
  # Initialize umap
  umap.params = umap::umap.defaults
  umap.params$n_neighbors=neighbors
  umap.params$n_components=components
  umap.params$n_epochs=epochs
  umap.params$random_state=1
  umap.params$transform_state=1
  umap.params$verbose=TRUE

  # Create data frame
  umap_data <- umap::umap(t(assay(object)))
  df.umap <- data.frame(umap_data$layout) %>%
    tibble::rownames_to_column("id") %>%
    dplyr::inner_join(as.data.frame(colData(object)), by = "id")

  # Create plot
  if (length(variables) == 2) {
    
    if (is.numeric(df.umap[[variables[1]]])) {
      
      p.umap <- ggplot(data = df.umap, aes(x = X1, y = X2, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
        geom_point(size = size, alpha = alpha) + labs(fill = legend_names[1], shape = legend_names[2]) +
        scale_shape_manual(values = shapes) +
        scale_fill_gradient(low = "white", high = "red")
      
    } else {
      
      p.umap <- ggplot(data = df.umap, aes(x = X1, y = X2, fill = .data[[variables[1]]], shape = .data[[variables[2]]])) +
        geom_point(size = size, alpha = alpha) + labs(fill = legend_names[1], shape = legend_names[2]) +
        scale_shape_manual(values = shapes) +
        scale_fill_manual(values = colors, guide = guide_legend(override.aes = list(shape = shapes[1])))
       
    }

  } else if (length(variables) == 1) {
    
    if (is.numeric(df.umap[[variables]])) {
      
      p.umap <- ggplot(data = df.umap, aes(x = X1, y = X2, fill = .data[[variables]])) +
        geom_point(size = size, alpha = alpha, shape = shapes[1]) +
        scale_fill_gradient(low = "white", high = "red") +
        labs(fill = legend_names[1])
      
    } else {
      
      p.umap <- ggplot(data = df.umap, aes(x = X1, y = X2, fill = .data[[variables]])) +
        geom_point(size = size, alpha = alpha, shape = shapes[1]) +
        scale_fill_manual(values = colors, guide = guide_legend(override.aes = list(shape = shapes[1]))) +
        labs(fill = legend_names[1])
      
    }
    
  }
  
  p.umap <- p.umap + coord_fixed() + theme_bw() +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          legend.title = element_text(size = legend_title, face = "bold"),
          legend.text = element_text(size = legend_elements),
          #legend.background = element_rect(color = "black"),
          legend.position = c(legend_pos[1], legend_pos[2]),
          legend.box.just = legend_pos[3])

  # Manage labels and tags
  if (is.null(labels) == FALSE) {

    # Add the column of labels to the data frame
    df.umap <- data.frame(df.umap, colData(object)[, labels[1], drop = FALSE])

    # Add the labels to the plot
    p.umap <- p.umap +
      geom_text(aes(label = df.umap[,labels[1]]), color = "black", size = as.numeric(labels[2]))
  }

  if(is.null(name_tags) == FALSE) {

    if (!requireNamespace("ggrepel", quietly = TRUE)) {
      stop(
        "Package \"ggrepel\" must be installed to use this function.",
        call. = FALSE
        )
    }

    # Add the column of name tags to the data frame
    df.umap <- data.frame(df.umap, colData(object)[, name_tags[1], drop = FALSE])

    # Add the name tags to the plot
    p.umap <- p.umap +
      ggrepel::geom_text_repel(aes(label = df.umap[,name_tags[1]]),
                               color = "black", cex = as.numeric(name_tags[2]),
                               min.segment.length = unit(as.numeric(name_tags[3]), "lines"),
                               box.padding = unit(as.numeric(name_tags[4]), "lines"))
  }

  if (returnData) {
    return(df.umap)
  } else {
    return(p.umap)
  }
}

############
# 2D UMAP
############
neigh <- 3
comp <- 2
iter <- 10000

for (i in seq_along(confounding_var)) {
  UMAP_plot <- UMAP_clust(
    transf.data, neighbors = neigh, components = comp, epochs = iter,
    variables = c(confounding_var[i], "sex"),
    legend_names = c(confounding_name[i], "Sex"),
    colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"),
    shapes = 21:22,
    legend_title = 15,
    legend_elements = 14,
    legend_pos = NULL,
    labels = NULL
  )
  
  print(UMAP_plot)
  
  ggsave(filename = paste0("plots/dim_reduction/UMAP/UMAP_n", neigh, "_", comp, "D_", (iter/1000), "k_", confounding_var[i], ".jpg"),
         plot = UMAP_plot, width = 7, height = 6, dpi = 300)
}

# Clustering
#UMAP_plot <- UMAP_clust(transf.data, neighbors = neigh, components = comp, epochs = iter,
#                        variables = c("Cluster", "sex"), legend_names = c("Cluster", "Sex"),
#                        colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"), shapes = 21:22, legend_title = 15,
#                        legend_elements = 14, legend_pos = NULL, labels = NULL,
#                        cluster_data = TRUE, min_points = 5)
#UMAP_plot

# Without sample 11
#UMAP_plot <- UMAP_clust(transf.data[, colnames(transf.data) != "301-1"], neighbors = neigh, components = comp, epochs = iter,
#                        variables = c("group", "sex"), legend_names = c("Group", "Sex"),
#                        colors = c(my_colors, "#87cefa", "#ffa07a", "#ffe4b5", "#98fb98", "#dda0dd"), shapes = 21:22, legend_title = 15,
#                        legend_elements = 14, legend_pos = NULL, labels = NULL)
#UMAP_plot

#ggsave(filename = paste0("plots/dim_reduction/UMAP/UMAP_n", neigh, "_", comp, "D_", (iter/1000), "k_group_wo_", 11, ".jpg"),
#       plot = UMAP_plot, width = 7, height = 6, dpi = 300)

############
# 3D UMAP
############
# Set up
umap_data <- umap::umap(t(assay(transf.data)),
                        config = modifyList(umap::umap.defaults, list(
                          n_neighbors = neigh,
                          n_components = comp + 1,
                          n_epochs = iter,
                          random_state = 1,
                          transform_state = 1,
                          verbose = TRUE)))


df.umap <- data.frame(umap_data$layout) %>%
  tibble::rownames_to_column("id") %>%
  dplyr::inner_join(as.data.frame(colData(transf.data)), by = "id")

# Plot
umap_plot <- plot_ly(
  data = df.umap,
  x = ~X1, y = ~X2, z = ~X3,
  type = "scatter3d", mode = "markers",
  color = ~group, colors = my_colors,
  marker = list(size = 10, line = list(color = "black", width = 1)),
  symbol = ~sex, symbols = c("circle", "square")
) %>%
  layout(scene = list(
    xaxis = list(title = "", showticklabels = FALSE),
    yaxis = list(title = "", showticklabels = FALSE),
    zaxis = list(title = "", showticklabels = FALSE)
  ), showlegend = TRUE)

# Save Plot
htmlwidgets::saveWidget(umap_plot, paste0("plots/dim_reduction/UMAP/Umap_n", neigh, "_",
                                          comp + 1, "D_", iter / 1000, "k_group", ".html"))
```

## Heatmap Samples vs Samples

```{r}
####################
# Samples Heatmaps #
####################

sampleDistMatrix <- as.matrix(dist(t(assay(transf.data))))

# List of Configurations
heatmap_configs <- list(
  list(row_var = "id", col_var = "group", filename = "Heatmap_samples_v1"),
  list(row_var = "num", col_var = "group", filename = "Heatmap_samples_v2")
)

# Generate and Save Heatmaps Using lapply
lapply(heatmap_configs, function(config) {
  # Update row and column names dynamically
  rownames(sampleDistMatrix) <- paste(transf.data[[config$row_var]], transf.data[[config$col_var]], sep = "_")
  colnames(sampleDistMatrix) <- paste(transf.data[[config$row_var]], transf.data[[config$col_var]], sep = "_")
  
  # Generate Heatmap
  heatmap_samples <- pheatmap(sampleDistMatrix, clustering_method = "complete", angle_col = 90)
  
  # Save Heatmap as SVG and PNG
  #ggsave(paste0("plots/dim_reduction/Heatmaps/", config$filename, ".svg"),
  #       plot = heatmap_samples, width = 7, height = 7, dpi = 300)
  ggsave(paste0("plots/dim_reduction/Heatmaps/", config$filename, ".jpg"),
         plot = heatmap_samples, width = 7, height = 7, dpi = 300)
})
```

## Obtain comparisons

```{r}
# Model matrix
ds.deseq <- DESeq(ds.deseq, modelMatrixType="standard", betaPrior=FALSE)

## DESeq2's dispersion estimates
plotDispEsts(ds.deseq)

# This will show the possible comparisons, according to the design provided
resultsNames(ds.deseq)

cutoff_alpha <- 0.25 # Cut off p-value
cutoff_fold <- 1 # Cut off fold-change
```

# 4. Results

```{r}
res.TB_C <- results(ds.deseq, name = "group_TB_vs_Control",
                    altHypothesis="greaterAbs",
                    alpha = cutoff_alpha,
                    #independentFiltering = TRUE, # Automatic filtering
                    pAdjustMethod = "BH") # Benjamini Hochberg = FDR

summary(res.TB_C)
head(res.TB_C[(res.TB_C$padj < cutoff_alpha) & !is.na(res.TB_C$padj), ], n = 10)
```

## Annotate results

```{r}
add_annotations_mod <- function(object, reference, variables = NULL){

  # Gene IDs as rownames
  object$geneID <- rownames(object)
  
  # Match gene IDs and extract annotation variables
  index <- match(object$geneID, reference$geneID)
  object[, variables] <- reference[index, variables]

  return(object)
}

res.TB_C <- add_annotations_mod(res.TB_C, geneID.details, variables = annotations)
colnames(res.TB_C)[7] <- "ensembl"

write.xlsx(res.TB_C, file = paste0("results/res_TB_vs_C_", dea_formula, "_all.xlsx"),
           colNames = TRUE, rowNames = FALSE, append = FALSE, overwrite = TRUE)

# Significant
res.TB_C.sig <- subset(res.TB_C, ((padj < cutoff_alpha) & !is.na(padj)))

write.xlsx(res.TB_C.sig, file = paste0("results/res_TB_vs_C_", dea_formula, "_padj<0.25.xlsx"),
           colNames = TRUE, rowNames = FALSE, append = FALSE, overwrite = TRUE)
```

## Detectability

```{r}
# Detectable differentially expressed genes
detect_list <- detect_filter(norm.counts = normalized.counts[, 1:19],
                             df.BvsA = res.TB_C.sig,
                             cutoffs = c(50, 50, 0),
                             samples.baseline = 11:19,
                             samples.condition1 = 1:10)
detect_list$DetectGenes

res.TB_C.det <- res.TB_C.sig[rownames(res.TB_C.sig) %in% detect_list$DetectGenes, ]

write.xlsx(res.TB_C.det, file = paste0("results/res_TB_vs_C_", dea_formula, "padj<0.25_detectable.xlsx"),
           colNames = TRUE, rowNames = FALSE, append = FALSE, overwrite = TRUE)
write.xlsx(res.TB_C.det[res.TB_C.det$padj < 0.05, ], file = paste0("results/res_TB_vs_C_", dea_formula, "padj<0.05_detectable.xlsx"),
           colNames = TRUE, rowNames = FALSE, append = FALSE, overwrite = TRUE)
write.xlsx(res.TB_C.det[res.TB_C.det$padj < 0.01, ], file = paste0("results/res_TB_vs_C_", dea_formula, "padj<0.01_detectable.xlsx"),
           colNames = TRUE, rowNames = FALSE, append = FALSE, overwrite = TRUE)

```

# 5. Plotting

## BSV plots of selected genes

```{r}
# Create data frame
df.box <- data.frame()
sig_data <- data.frame()

for (gene in x$ensembl[x$symbol %in% c("VCAN", "SLC11A1", "CTSB")]) {
  gene_counts <- counts(ds.deseq, normalized = TRUE)[gene, ]
  log2_gc <- log2(gene_counts)
  
  df.box <- rbind(df.box,
                  data.frame(ds.deseq@colData[, c("id", "group", "sex", "age", "age_cat", "num")],
                             log2_gc,
                             gene = rep(x[gene, "symbol"], 19)))
  
  sig_data <- rbind(sig_data,
                    data.frame(gene = rep(x[gene, "symbol"], 1),
                               group1 = c("Control"),
                               group2 = c("TB"),
                               ypos = c(max_value + prop),
                               label = c(get_stars(x[gene, "ensembl"], res.TB_C))
                               )
                    )
}

# Facetted plot
p.bs <- ggplot(df.box, aes(x = group, y = log2_gc)) + theme_bw() +
  
  # Violin plot
  geom_violin(scale = "count", fill = NA, colour = "peru", show.legend = FALSE, trim = TRUE, linewidth = 0.7) +
  
  # Box plot with error bar
  geom_boxplot(width = 0.07, fill = "gray90") +
  geom_errorbar(stat = "boxplot", width = 0.3, linewidth = 1, color = "black",
                aes(ymin = after_stat(middle), ymax = after_stat(middle))) +
  
  # Scatter plot
  geom_point(aes(fill = group), shape = 21, size = 5, position = position_jitter(width = 0.15)) +
  
  facet_wrap(~ gene, nrow = 1) +
  
  # Axis labels
  labs(x = NULL, y = expression("log"[2]*"(Normalized Counts)")) +
  
  # Axis text size
  theme(title = element_blank(),
        axis.text.x = element_text(size = 24),
        axis.text.y = element_text(size = 16),
        axis.title.y = element_text(size = 22),
        axis.title.x = element_blank(),
        strip.text = element_text(size = 20, face = "bold"),
        strip.background = element_rect(fill = "gray90", colour = "black"),
        panel.grid.major = element_line(colour = "gray80", linetype = "dashed", linewidth = 0.25),
        panel.grid.minor = element_line(colour = "gray80", linetype = "dashed", linewidth = 0.25),
        legend.position = "none") +
  
  # Legend setting
  scale_fill_manual(name = "Group", values = c("Control" = "#bbffff", "TB" = "#ffb6c1"))


# Set max and min values without considering +/- Inf values
min_value <- min(df.box$log2_gc[is.finite(df.box$log2_gc)])
max_value <- max(df.box$log2_gc[is.finite(df.box$log2_gc)])

# Generating y position for the significance bars
## Objective: maintain same proportion in distance for each plot
y_range <- diff(range(df.box$log2_gc[is.finite(df.box$log2_gc)]))
prop <- 0.08*y_range

p.bs <- p.bs + scale_y_continuous(breaks = seq(floor(min_value), ceiling(max_value), by = 2))
p.bs <- p.bs + geom_signif(data = sig_data, manual = TRUE, size = 1.7, colour = "grey5",
                           aes(xmin = group1, xmax = group2, annotations = label, y_position = 14.2),
                           textsize = 7, vjust = 0, tip_length = 0.02)

ggsave(filename = paste0("plots/BSV_top_hits_facet.jpg"), plot = p.bs, width = 11, height = 7.5, dpi = 300)
```

## Volcano plot

```{r}
# Parameters
## padj and FC tresholds
ctf_nice <- 0.01
fld_nice <- cutoff_fold * 4

d.volcano <- data.frame(res.TB_C)
d.volcano <- d.volcano[!is.na(d.volcano$padj), ]
d.volcano$log2FoldChange[d.volcano$log2FoldChange > 8] <- 8
d.volcano$log2FoldChange[d.volcano$log2FoldChange < -8] <- -8
d.volcano$padj[d.volcano$padj < 10**-3] <- 10**-3
d.volcano$padj[d.volcano$padj > 10**8] <- 10**8

d.volcano$colors <- rep("other", nrow(d.volcano))
d.volcano$colors[(d.volcano$log2FoldChange >= cutoff_fold & d.volcano$padj < cutoff_alpha)] <- "over"
d.volcano$colors[(d.volcano$log2FoldChange <= -cutoff_fold & d.volcano$padj < cutoff_alpha)] <- "under"

d.volcano$shapes <- rep("nohits", nrow(d.volcano))
#d.volcano$shapes[(abs(d.volcano$log2FoldChange) >= fld_nice & d.volcano$padj == 10**-3)] <- "hits"
d.volcano$shapes[d.volcano$padj <= 10**-3] <- "hits"

# Condition for labeling
cond <- d.volcano$ensembl %in% detect_list$DetectGenes & d.volcano$padj == 0.001 & abs(d.volcano$log2FoldChange) > fld_nice
sum(cond)

p.volcano <- ggplot() + theme_bw() +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, 3.07),
                     breaks = seq(1, 5, by = 1),
                     minor_breaks = seq(0, 5, by = 1)) +
  scale_x_continuous(expand = c(0,0),
                     limits = c(-9.5, 9.5),
                     breaks = seq(-9, 9, by = 3),
                     minor_breaks = seq(-9, 9, by = 1)) +
  
  # Vertical lines and labels:
  geom_vline(xintercept = c(-cutoff_fold, cutoff_fold), color = "grey20", alpha = 0.8, linetype = 2, linewidth = 1.2) +
  #geom_text(aes(x = -cutoff_fold - 1.3, y = 2.7, label = paste("x =", -cutoff_fold)), color = "grey20", size = 6.2) +
  #geom_text(aes(x = cutoff_fold + 1.3, y = 2.7, label = paste("x =", cutoff_fold)), color = "grey20", size = 6.2) +
  
  # Horizontal line and label:
  geom_hline(yintercept = -log10(cutoff_alpha), color = "grey20", alpha = 0.8, linetype = 2, linewidth = 1.2) +
  geom_text(aes(x = -7.35, y = -log10(cutoff_alpha) + 0.15, label = paste("q =", cutoff_alpha)), color = "grey20", size = 6.2) +
  
  # Datapoints, in different colors:
  geom_point(data = d.volcano,
             aes(x = log2FoldChange, y = -log10(padj), fill = colors, shape = shapes),
             size = 5.5, color = "gray10", alpha = 0.4, show.legend = TRUE) +
  
  # Color settings
  scale_fill_manual(name = "Expression",
                    values = c("over" = "red", "other" = "grey50", "under" = "blue"),
                    guide = guide_legend(override.aes = aes(shape = 21, size = 5, alpha = 1)),
                    labels = c("Up-regulated", "Others", "Down-regulated")) +
  
  # Change outliers shapes
  scale_shape_manual(name = "Shape",
                     values = c("hits" = 24, "nohits" = 21),
                     guide = guide_legend(override.aes = list(fill = "white", size = 5, alpha = 1)),
                     labels = c(expression(FDR <= 10^-3), expression(FDR > 10^-3))) +
  
  # Labels for detectable genes
  geom_label_repel(data = d.volcano[cond, ],
                   aes(x = log2FoldChange, y = -log10(padj), label = symbol),
                   inherit.aes = FALSE,
                   parse = FALSE,
                   max.iter = 5000,
                   color = "black",
                   size = 7.2,
                   segment.alpha = 1.5,
                   box.padding = unit(0.8, "lines"),
                   min.segment.length = unit(0.01, "lines")) +
  
  # Axis labels:
  labs(x = expression("log"[2]*"(Fold Change)"),
       y = expression("-log"[10]*"FDR"),
       #y = expression("-log(FDR)"),
       title = "TB over Control") +
  
  # Labels size
  theme(plot.title = element_text(size = 26, hjust = 0.5),
        axis.text = element_text(size = 22),
        axis.title = element_text(size = 26),
        legend.text = element_text(size = 18),
        legend.title = element_text(size= 19, face = "bold"))

# p.volcano <- p.volcano + theme(element_text(20))
# p.volcano <- p.volcano + theme(legend.position = "none")
p.volcano

#ggsave("plots/Ap_An_Volcano_detect.pdf", p.volcano, width = 10.5, height = 8, dpi = 300, device = "pdf")
ggsave(paste0("plots/volcano/TB_Control_volcano_", dea_formula, "_detectable_", "padj<0.001", ".jpg"),
       p.volcano, width = 11, height = 8, dpi = 300)
```

## Heatmap Samples vs Genes

```{r}
varst.data <- getVarianceStabilizedData(ds.deseq)

colors_samples = list(Group = c("Control" = "#bbffff",
                                "TB" = "#ffb6c1"))

genesTB <- res.TB_C.det[res.TB_C.det$padj < 0.01, c("ensembl", "symbol")]

# Filter rows by matching Ensembl IDs and reorder them to align with `genescardio`
varst.data.sig <- varst.data[rownames(varst.data) %in% genesTB$ensembl, ]
varst.data.sig <- varst.data.sig[match(genesTB$ensembl, rownames(varst.data.sig)), ]

# Rename the rows to gene symbols, ensuring they align correctly with `genescardio`
rownames(varst.data.sig) <- genesTB$symbol[match(rownames(varst.data.sig), genesTB$ensembl)]

# Create sample annotation and align sample order between `anot` and `varst.data.sig`
anot <- data.frame(Group = sampledata$group, row.names = sampledata$id)
anot$Group <- factor(anot$Group)
anot <- anot[order(anot$Group, decreasing = FALSE), , drop = FALSE]

# Align columns of `varst.data.sig` with ordered row names of `anot`
varst.data.sig <- varst.data.sig[, rownames(anot)]

# Set column names of `varst.data.sig` to match sample IDs from `sampledata`
colnames(varst.data.sig) <- rownames(anot)

#rownames(anot) <- 1:21
#colnames(varst.data.sig) <- 1:21

heatmap_genes <- pheatmap(varst.data.sig,
                          cluster_cols = TRUE,
                          cluster_rows = TRUE,
                          show_rownames = FALSE,
                          clustering_method = "mcquitty",
                          cellwidth = 9.4,
                          cellheight = 2,
                          treeheight_col = 15,
                          treeheight_row = 40,
                          scale = "row",
                          annotation = anot,
                          #annotation_legend = FALSE,
                          angle_col = 90,
                          annotation_colors = colors_samples,
                          kmeans_k = NA,
                          dpi = 300,
                          drop_levels = FALSE,
                          #cutree_rows = 2,
                          #gaps_col =  c(3, 6, 9),
                          #fontsize_row = 9.3,
                          #legend = TRUE,
                          show_colnames = FALSE)

ggsave("plots/heatmap/Heatmap_samples_TB_Control_(padj_0.05)_WPGMA.jpg",
       plot = heatmap_genes, width = 6, height = 9, dpi = 300, units = "in")
ggsave("plots/heatmap/Heatmap_samples_TB_Control_(padj_0.01)_WPGMA.jpg",
       plot = heatmap_genes, width = 6, height = 6, dpi = 300, units = "in")
```

# 6. GSEA

## GSE with clusterProfiler

```{r}
# Create a ranked list based on the log2 fold change
ranked_genes <- res.TB_C[order(res.TB_C$stat, decreasing = TRUE), ]
ranked_genes <- ranked_genes[!is.na(ranked_genes$stat), ]

# Extract the gene symbols and log2 fold changes
ranked_list <- ranked_genes$stat
names(ranked_list) <- ranked_genes$ensembl

ranked_list

#####################
# Enriched GO terms #
#####################
# BP
gseGO_BP <- gseGO(geneList = ranked_list,
                  ont = "BP",
                  OrgDb = "org.Hs.eg.db",
                  keyType = "ENSEMBL",
                  eps = 1e-300,
                  verbose = TRUE)

gseGO_BP.df <- as.data.frame(gseGO_BP)
View(gseGO_BP.df)

gseaplot(x = gseGO_BP, geneSetID = 1)
dotplot(gseGO_BP)

# CC
gseGO_CC <- gseGO(geneList = ranked_list,
                  ont = "CC",
                  OrgDb = "org.Hs.eg.db",
                  keyType = "ENSEMBL",
                  eps = 1e-300,
                  verbose = TRUE)

gseGO_CC.df <- as.data.frame(gseGO_CC)
View(gseGO_CC.df)

gseaplot(x = gseGO_CC, geneSetID = 1)
dotplot(gseGO_CC)

# MF
gseGO_MF <- gseGO(geneList = ranked_list,
                  ont = "MF",
                  OrgDb = "org.Hs.eg.db",
                  keyType = "ENSEMBL",
                  eps = 1e-300,
                  verbose = TRUE)

gseGO_MF.df <- as.data.frame(gseGO_MF)
View(gseGO_MF.df)

gseaplot(x = gseGO_MF, geneSetID = 1)
dotplot(gseGO_MF)
```

### Lollipop plots

```{r}
# Prepare data
geneRatios <- c()


for (i in 1:nrow(gseGO_CC.df)) {
  idk <- strsplit(gseGO_CC.df$core_enrichment[i], "/")
  geneRatios[i] <- length(idk[[1]])/gseGO_CC.df$setSize[i]
}

gseGO_CC.df$GeneRatio <- geneRatios

gseGO_BP.df[, "-Log10FDR"] <- -log10(gseGO_BP.df$qvalue)
gseGO_CC.df[, "-Log10FDR"] <- -log10(gseGO_CC.df$qvalue)
gseGO_MF.df[, "-Log10FDR"] <- -log10(gseGO_MF.df$qvalue)

write.xlsx(gseGO_BP.df, file = "gseGO_BP.xlsx")
write.xlsx(gseGO_CC.df, file = "gseGO_CC.xlsx")

# Plotting
# BP #
lollipop_data <- gseGO_BP.df
lollipop_data <- gseGO_BP.df[gseGO_BP.df$p.adjust < 2.6e-18, ]
lollipop_data <- lollipop_data[order(lollipop_data$`-Log10FDR`, decreasing = F), ]
lollipop_data$Description <- factor(lollipop_data$Description, levels = lollipop_data$Description)

ggplot(lollipop_data, aes(x = `-Log10FDR`, y = Description)) +
  # Larger circle
  geom_point(aes(size = setSize), shape = 21, fill = "white", color = "black") +
  
  # Inner circle
  geom_point(aes(size = setSize * GeneRatio, color = NES)) +
  theme_bw() +
  scale_color_gradient(low = "gold2", high = "red") +
  
  # Additional scale for the inner circle size (based on GeneRatio)
  scale_size_continuous(name = "Set Size", range = c(6, 15),
                        limits = c(floor(min(lollipop_data$setSize * lollipop_data$GeneRatio)),
                                   ceiling(max(lollipop_data$setSize)))) +
  theme(
    axis.text.x = element_text(size = 12, vjust = 1),
    axis.text.y = element_text(size = 12, hjust = 1),
    strip.text.x = element_text(face = "bold", size = 10),
    strip.text.y = element_text(face = "bold", size = 10, angle = 90, hjust = 0.5),
    strip.background = element_rect(fill = "gray90", colour = "white", linewidth = 1),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_line(linewidth = 0.2, linetype = 'solid', color = "grey90"),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(face = "bold", size = 16, vjust = 1),
    axis.title.y = element_text(face = "bold", size = 16, vjust = 1)
  ) +
  labs(size = "Gene Ratio", color = "NES", y = "Biological Proccess", x = "-Log10FDR") +
  guides(size = guide_legend(override.aes = list(shape = 21, fill = "white", color = "black")))

ggsave("plots/gseGO_BP.jpg", height = 8, width = 11, dpi = 300)


# CC #
lollipop_data <- gseGO_CC.df
lollipop_data <- gseGO_CC.df[gseGO_CC.df$p.adjust < 2.36e-21, ]
lollipop_data <- lollipop_data[order(lollipop_data$`-Log10FDR`, decreasing = F), ]
lollipop_data$Description <- factor(lollipop_data$Description, levels = lollipop_data$Description)

ggplot(lollipop_data, aes(x = `-Log10FDR`, y = Description)) +
  # Larger circle
  geom_point(aes(size = setSize), shape = 21, fill = "white", color = "black") +
  
  # Inner circle
  geom_point(aes(size = setSize * GeneRatio, color = NES)) +
  theme_bw() +
  scale_color_gradient(low = "gold2", high = "red") +
  
  # Additional scale for the inner circle size (based on GeneRatio)
  scale_size_continuous(name = "Set Size", range = c(6, 15), limits = c(floor(min(lollipop_data$setSize * lollipop_data$GeneRatio)),
                                                                        ceiling(max(lollipop_data$setSize)))) +
  theme(
    axis.text.x = element_text(size = 12, vjust = 1),
    axis.text.y = element_text(size = 12, hjust = 1),
    strip.text.x = element_text(face = "bold", size = 10),
    strip.text.y = element_text(face = "bold", size = 10, angle = 90, hjust = 0.5),
    strip.background = element_rect(fill = "gray90", colour = "white", linewidth = 1),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_line(linewidth = 0.2, linetype = 'solid', color = "grey90"),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(face = "bold", size = 16, vjust = 1),
    axis.title.y = element_text(face = "bold", size = 16, vjust = 1)
  ) +
  labs(size = "Gene Ratio", color = "NES", y = "Cellular Component", x = "-Log10FDR") +
  guides(size = guide_legend(override.aes = list(shape = 21, fill = "white", color = "black")))

ggsave("plots/gseGO_CC.jpg", height = 8, width = 11, dpi = 300)


# MF #
lollipop_data <- gseGO_MF.df
lollipop_data <- gseGO_MF.df[gseGO_MF.df$p.adjust < 7.2e-8, ]
lollipop_data <- lollipop_data[order(lollipop_data$`-Log10FDR`, decreasing = F), ]
lollipop_data$Description <- factor(lollipop_data$Description, levels = lollipop_data$Description)

ggplot(lollipop_data, aes(x = `-Log10FDR`, y = Description)) +
  # Larger circle
  geom_point(aes(size = setSize), shape = 21, fill = "white", color = "black") +
  
  # Inner circle
  geom_point(aes(size = setSize * GeneRatio, color = NES)) +
  theme_bw() +
  scale_color_gradient(low = "gold2", high = "red") +
  
  # Additional scale for the inner circle size (based on GeneRatio)
  scale_size_continuous(name = "Set Size", range = c(6, 15), limits = c(floor(min(lollipop_data$setSize * lollipop_data$GeneRatio)),
                                                                        ceiling(max(lollipop_data$setSize)))) +
  theme(
    axis.text.x = element_text(size = 12, vjust = 1),
    axis.text.y = element_text(size = 12, hjust = 1),
    strip.text.x = element_text(face = "bold", size = 10),
    strip.text.y = element_text(face = "bold", size = 10, angle = 90, hjust = 0.5),
    strip.background = element_rect(fill = "gray90", colour = "white", linewidth = 1),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_line(linewidth = 0.2, linetype = 'solid', color = "grey90"),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(face = "bold", size = 16, vjust = 1),
    axis.title.y = element_text(face = "bold", size = 16, vjust = 1)
  ) +
  labs(size = "Gene Ratio", color = "NES", y = "Molecular Function", x = "-Log10FDR") +
  guides(size = guide_legend(override.aes = list(shape = 21, fill = "white", color = "black")))

ggsave("plots/gseGO_MF.jpg", height = 8, width = 11, dpi = 300)
```

### Network plots

```{r}
# Require library
library("igraph")
library("ggraph")
library("tidygraph")
library("scales")

# Extract top GO terms data
gseGO_BP@result[, "-Log10FDR"] <- -log10(gseGO_BP@result$qvalue)
top_terms <- head(gseGO_BP@result, 12)
#top_terms$Description[13] <- "adaptive immune response"
#top_terms$Description[11] <- "external stimulus response inhibition"

# Create an empty graph
g <- make_empty_graph(directed = FALSE)

# Add nodes (gene sets) to the graph
g <- add_vertices(g, n = nrow(top_terms), name = top_terms$ID, label = top_terms$Description)

# Add edges (overlap) to the graph, adding multiple edges based on the overlap count
for (i in 1:(nrow(top_terms)-1)) {
  for (j in (i+1):nrow(top_terms)) {
    genes_i <- unlist(strsplit(top_terms$core_enrichment[i], "/"))
    genes_j <- unlist(strsplit(top_terms$core_enrichment[j], "/"))
    overlap <- length(intersect(genes_i, genes_j))
    if (overlap > 0) {
      for (k in 1:overlap) {
        g <- add_edges(g, c(V(g)$name[i], V(g)$name[j]))
      }
    }
  }
}

# Convert igraph to tidygraph
tg <- as_tbl_graph(g)

# Add node attributes
V(g)$size <- top_terms$`-Log10FDR`
V(g)$color <- top_terms$NES

tg <- tg %>%
  mutate(size = top_terms$`-Log10FDR`[match(name, top_terms$ID)],
         color = top_terms$NES[match(name, top_terms$ID)],
         label = top_terms$Description[match(name, top_terms$ID)])

# Plot the network using ggraph
p <- ggraph(tg, layout = 'fr') + 
  geom_edge_link(alpha = 0.3, edge_colour = 'grey', width = 0.6) +
  geom_node_point(aes(size = size, color = color)) +
  geom_text_repel(aes(x = x , y = y + 0.05, label = label), size = 3.5, fontface = "bold", color = "black") +
  scale_size_continuous(name = "-Log10FDR", range = c(4, 10)) +
  scale_color_gradient(name = "NES", low = "gold2", high = "red") +
  theme_classic(base_size = 10) +
  theme(
    legend.position = "right",
    panel.background = element_rect(fill = "white", colour = NA),
    plot.background = element_rect(fill = "white", colour = NA),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    panel.grid = element_blank()
  ) +
  guides(size = guide_legend(override.aes = list(shape = 21, fill = "white", color = "black")))
  #+ labs(title = "Enriched GO Terms in Ap vs An")

# Print the plot
print(p)

ggsave("plots/gseGO_BP_network.jpg", p, width = 10, height = 10, dpi = 600)
```

## PADOG

```{r}
#library("PADOG", quietly = T)
```

## Standalone tool
There are 3 inputs needed for GSEA:
- *Expression data*: File with normalized counts, columns must be sample IDs and an gene identifiers.
- *Phenotype info*: File indicating the amount of classes and which samples correspond to each phenotype.
- *GMT*: Gene matrices of sets from the MSigDB data base.

### Prepare files

```{r}
# Expression data
expression_data_TB <- normalized.counts.annotated
expression_data_TB <- expression_data_TB[, c(22, 29, 1:19)]
colnames(expression_data_TB)[1:2] <- c("NAME", "DESCRIPTION")
expression_data_TB$DESCRIPTION <- rep(NA, nrow(expression_data_TB))

# Write to a tab-separated file
write.table(expression_data_TB, file = "GSEA/expression_data_TB.txt",
            sep = "\t", row.names = FALSE, quote = FALSE)

# Phenotype info
## Number of classes
n_classes <- length(levels(sampledata$group))

# Create .cls file content
cls_header <- paste(nrow(sampledata), n_classes, "1")
cls_classes <- paste0("# ", "TB Control")
cls_labels <- paste(sampledata$group, collapse = " ")
cls_content <- paste(cls_header, cls_classes, cls_labels, sep = "\n")

## Write to .cls file
write(cls_content, file = "GSEA/phenotype_CCC.cls")
```

### Get GMTs
- Enter the (MsigDB Downloads)[https://www.gsea-msigdb.org/gsea/downloads.jsp] page and retrieve the
**Human Gene Set GMT file set (ZIPped)**
- After that, follow the (GSEA User Guide)[https://docs.gsea-msigdb.org/#GSEA/GSEA_User_Guide/] instructions to run GSEA.

### Results GSEA

```{r}
########################################
# Function to manage GSEA results data #
########################################
sortGSEAdata <- function (gseaD, collection, phenotype) {
  gseaD <- gseaD[, -c(2:3, 10:12)]
  gseaD$COLLECTION <- rep(collection, nrow(gseaD))
  gseaD <- gseaD[, c(ncol(gseaD), 1:(ncol(gseaD)-1))]
  colnames(gseaD)[6:8] <- c("NOM_pval", "FDR_qval", "FWER_pval")
  gseaD[, "-Log10FDR"] <- -log10(gseaD$FDR_qval)
  gseaD$PHENOTYPE <- rep(phenotype, nrow(gseaD))
  gseaD$COMPARISON <- rep("TB vs Control", nrow(gseaD))
  
  return(gseaD)
}

# Testing functions
test <- "GSEA/H/jun03/my_analysis.Gsea.1717455994490/gsea_report_for_TB_1717455994490.tsv"
strsplit(test, split = "_")[[1]][5]

gseaTest <- data.frame(read.csv("GSEA/H/jun03/my_analysis.Gsea.1717455994490/gsea_report_for_TB_1717455994490.tsv",
                                sep = "\t", header = TRUE))
gseaTest <- gseaTest[, -c(2, 3, 12)]

sortTest <- sortGSEA(file = "GSEA/H/jun03/my_analysis.Gsea.1717455994490/gsea_report_for_TB_1717455994490.tsv",
                     collection = "C2",
                     subcollection = "CGP")

plotTest <- plotGSEA(gseaD = sortTest, fdr_threshold = 0.5)
plotTest


#####
# H #
#####
H.up <- data.frame(read.csv("GSEA/H/jun03/my_analysis.Gsea.1717455994490/gsea_report_for_TB_1717455994490.tsv",
                            sep = "\t", header = TRUE))
H.dn <- data.frame(read.csv("GSEA/H/jun03/my_analysis.Gsea.1717455994490/gsea_report_for_Control_1717455994490.tsv",
                            sep = "\t", header = TRUE))
H.up <- sortGSEAdata(H.up, "H", "TB")
H.dn <- sortGSEAdata(H.dn, "H", "C")

H <- rbind(H.up, H.dn)
write.xlsx(H, "GSEA/H_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(H[H$FDR_qval < 0.25, ], "GSEA/H_filetered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C1 #
######
#C1.up <- data.frame(read.csv("GSEA/C1/jun03/my_analysis.Gsea.1717456144731/gsea_report_for_TB_1717456144731.tsv",
#                             sep = "\t", header = TRUE))
#C1.up <- C1.up[, -c(2, 3, 10:12)]
#C1.up$COLLECTION <- rep("C1", nrow(C1.up))
#C1.up <- C1.up[, c(ncol(C1.up), 1:(ncol(C1.up)-1))]
#colnames(C1.up)[6:8] <- c("NOM_pval", "FDR_qval", "FWER_pval")
#C1.up[, "-Log10FDR"] <- -log10(C1.up$FDR_qval)
#C1.up$PHENOTYPE <- rep("TB", nrow(C1.up))

# Retrieve data
C1.up <- data.frame(read.csv("GSEA/C1/jun03/my_analysis.Gsea.1717456144731/gsea_report_for_TB_1717456144731.tsv",
                             sep = "\t", header = TRUE))
C1.dn <- data.frame(read.csv("GSEA/C1/jun03/my_analysis.Gsea.1717456144731/gsea_report_for_Control_1717456144731.tsv",
                             sep = "\t", header = TRUE))

# Apply function
C1.up <- sortGSEAdata(C1.up, collection = "C1", phenotype = "TB")
C1.dn <- sortGSEAdata(C1.dn, collection = "C1", phenotype = "C")

# Merged data and geerate output
C1 <- rbind(C1.up, C1.dn)
write.xlsx(C1, "GSEA/C1_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C1[C1$FDR_qval < 0.25, ], "GSEA/C1_filetered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C2 #
######
C2_CGP.up <- data.frame(read.csv("GSEA/C2/CGP/jun03/my_analysis.Gsea.1717456977994/gsea_report_for_TB_1717456977994.tsv",
                                 sep = "\t", header = T))
C2_CGP.dn <- data.frame(read.csv("GSEA/C2/CGP/jun03/my_analysis.Gsea.1717456977994/gsea_report_for_Control_1717456977994.tsv",
                                 sep = "\t", header = T))
C2_CGP.up <- sortGSEAdata(C2_CGP.up, collection = "C2_CGP", phenotype = "TB")
C2_CGP.dn <- sortGSEAdata(C2_CGP.dn, collection = "C2_CGP", phenotype = "C")

C2_CP_REACTOME.up <- data.frame(read.csv("GSEA/C2/CP/REACTOME/jun03/my_analysis.Gsea.1717458827991/gsea_report_for_TB_1717458827991.tsv",
                                         sep = "\t", header = T))
C2_CP_REACTOME.dn <- data.frame(read.csv("GSEA/C2/CP/REACTOME/jun03/my_analysis.Gsea.1717458827991/gsea_report_for_Control_1717458827991.tsv",
                                         sep = "\t", header = T))
C2_CP_REACTOME.up <- sortGSEAdata(C2_CP_REACTOME.up, "C2_CP", "TB")
C2_CP_REACTOME.dn <- sortGSEAdata(C2_CP_REACTOME.dn, "C2_CP", "C")

C2_CP_KEGG.up <- data.frame(read.csv("GSEA/C2/CP/KEGG_MEDICUS/jun03/my_analysis.Gsea.1717458551224/gsea_report_for_TB_1717458551224.tsv",
                                     sep = "\t", header = T))
C2_CP_KEGG.dn <- data.frame(read.csv("GSEA/C2/CP/KEGG_MEDICUS/jun03/my_analysis.Gsea.1717458551224/gsea_report_for_Control_1717458551224.tsv",
                                     sep = "\t", header = T))
C2_CP_KEGG.up <- sortGSEAdata(C2_CP_KEGG.up, "C2_CP", "TB")
C2_CP_KEGG.dn <- sortGSEAdata(C2_CP_KEGG.dn, "C2_CP", "C")

C2 <- rbind(C2_CGP.up, C2_CGP.dn, C2_CP_REACTOME.up, C2_CP_REACTOME.dn, C2_CP_KEGG.up, C2_CP_KEGG.dn)
write.xlsx(C2, "GSEA/C2_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C2[C2$FDR_qval < 0.25, ], "GSEA/C2_filtered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C3 #
######
C3_MIR_LEGA.up <- data.frame(read.csv("GSEA/C3/MIR/MIR_LEGACY/jun03/my_analysis.Gsea.1717459963521/gsea_report_for_TB_1717459963521.tsv",
                                      sep = "\t", header = T))
C3_MIR_LEGA.dn <- data.frame(read.csv("GSEA/C3/MIR/MIR_LEGACY/jun03/my_analysis.Gsea.1717459963521/gsea_report_for_Control_1717459963521.tsv",
                                      sep = "\t", header = T))
C3_MIR_LEGA.up <- sortGSEAdata(C3_MIR_LEGA.up, "C3_MIR", "TB")
C3_MIR_LEGA.dn <- sortGSEAdata(C3_MIR_LEGA.dn, "C3_MIR", "C")

C3_MIR_DB.up <- data.frame(read.csv("GSEA/C3/MIR/MIRDB/jun03/my_analysis.Gsea.1717459276987/gsea_report_for_TB_1717459276987.tsv",
                                    sep = "\t", header = T))
C3_MIR_DB.dn <- data.frame(read.csv("GSEA/C3/MIR/MIRDB/jun03/my_analysis.Gsea.1717459276987/gsea_report_for_Control_1717459276987.tsv",
                                    sep = "\t", header = T))
C3_MIR_DB.up <- sortGSEAdata(C3_MIR_DB.up, "C3_MIR", "TB")
C3_MIR_DB.dn <- sortGSEAdata(C3_MIR_DB.dn, "C3_MIR", "C")

C3_TFT_GTRD.up <- data.frame(read.csv("GSEA/C3/TFT/GTRD/jun03/my_analysis.Gsea.1717460478526/gsea_report_for_TB_1717460478526.tsv",
                                      sep = "\t", header = T))
C3_TFT_GTRD.dn <- data.frame(read.csv("GSEA/C3/TFT/GTRD/jun03/my_analysis.Gsea.1717460478526/gsea_report_for_Control_1717460478526.tsv",
                                      sep = "\t", header = T))
C3_TFT_GTRD.up <- sortGSEAdata(C3_TFT_GTRD.up, "C3_TFT", "TB")
C3_TFT_GTRD.dn <- sortGSEAdata(C3_TFT_GTRD.dn, "C3_TFT", "C")

C3_TFT_LEGA.up <- data.frame(read.csv("GSEA/C3/TFT/TFT_LEGACY/jun04/my_analysis.Gsea.1717477332688/gsea_report_for_TB_1717477332688.tsv",
                                      sep = "\t", header = T))
C3_TFT_LEGA.dn <- data.frame(read.csv("GSEA/C3/TFT/TFT_LEGACY/jun04/my_analysis.Gsea.1717477332688/gsea_report_for_Control_1717477332688.tsv",
                                      sep = "\t", header = T))
C3_TFT_LEGA.up <- sortGSEAdata(C3_TFT_LEGA.up, "C3_TFT", "TB")
C3_TFT_LEGA.dn <- sortGSEAdata(C3_TFT_LEGA.dn, "C3_TFT", "C")

C3 <- rbind(C3_MIR_LEGA.up, C3_MIR_LEGA.dn, C3_MIR_DB.up, C3_MIR_DB.dn,
            C3_TFT_GTRD.up, C3_TFT_GTRD.dn, C3_TFT_LEGA.up, C3_TFT_LEGA.dn)
write.xlsx(C3, "GSEA/C3_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C3[C3$FDR_qval < 0.25, ], "GSEA/C3_filtered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C5 #
######
C5_GO_BP.up <- data.frame(read.csv("GSEA/C5/GO/BP/gsea_report_for_TB_1717458561381.tsv",
                                   sep = "\t", header = T))
C5_GO_BP.dn <- data.frame(read.csv("GSEA/C5/GO/BP/gsea_report_for_Control_1717458561381.tsv",
                                   sep = "\t", header = T))
C5_GO_BP.up <- sortGSEAdata(C5_GO_BP.up, "C5_GOBP", "TB")
C5_GO_BP.dn <- sortGSEAdata(C5_GO_BP.dn, "C5_GOBP", "C")

C5_GO_CC.up <- data.frame(read.csv("GSEA/C5/GO/CC/gsea_report_for_TB_1717459154257.tsv",
                                   sep = "\t", header = T))
C5_GO_CC.dn <- data.frame(read.csv("GSEA/C5/GO/CC/gsea_report_for_Control_1717459154257.tsv",
                                   sep = "\t", header = T))
C5_GO_CC.up <- sortGSEAdata(C5_GO_CC.up, "C5_GOCC", "TB")
C5_GO_CC.dn <- sortGSEAdata(C5_GO_CC.dn, "C5_GOCC", "C")

C5_GO_MF.up <- data.frame(read.csv("GSEA/C5/GO/MF/gsea_report_for_TB_1717459353814.tsv",
                                   sep = "\t", header = T))
C5_GO_MF.dn <- data.frame(read.csv("GSEA/C5/GO/MF/gsea_report_for_Control_1717459353814.tsv",
                                   sep = "\t", header = T))
C5_GO_MF.up <- sortGSEAdata(C5_GO_MF.up, "C5_GOMF", "TB")
C5_GO_MF.dn <- sortGSEAdata(C5_GO_MF.dn, "C5_GOMF", "C")

C5_HPO.up <- data.frame(read.csv("GSEA/C5/HPO/gsea_report_for_TB_1717459623478.tsv",
                                 sep = "\t", header = T))
C5_HPO.dn <- data.frame(read.csv("GSEA/C5/HPO/gsea_report_for_Control_1717459623478.tsv",
                                 sep = "\t", header = T))
C5_HPO.up <- sortGSEAdata(C5_HPO.up, "C5_HPO", "TB")
C5_HPO.dn <- sortGSEAdata(C5_HPO.dn, "C5_HPO", "C")


C5 <- rbind(C5_GO_BP.up, C5_GO_BP.dn, C5_GO_CC.up, C5_GO_CC.dn,
            C5_GO_MF.up, C5_GO_MF.dn, C5_HPO.up, C5_HPO.dn)
write.xlsx(C5, "GSEA/C5_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C5[C5$FDR_qval < 0.25, ], "GSEA/C5_filtered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C7 #
######
C7_IMMUNE.up <- data.frame(read.csv("GSEA/C7/IMMUNESIGDB/gsea_report_for_TB_1717460259438.tsv",
                                    sep = "\t", header = T))
C7_IMMUNE.dn <- data.frame(read.csv("GSEA/C7/IMMUNESIGDB/gsea_report_for_Control_1717460259438.tsv",
                                    sep = "\t", header = T))
C7_IMMUNE.up <- sortGSEAdata(C7_IMMUNE.up, "C7", "TB")
C7_IMMUNE.dn <- sortGSEAdata(C7_IMMUNE.dn, "C7", "C")

C7_VAX.up <- data.frame(read.csv("GSEA/C7/VAX/gsea_report_for_TB_1717461016464.tsv",
                                 sep = "\t", header = T))
C7_VAX.dn <- data.frame(read.csv("GSEA/C7/VAX/gsea_report_for_Control_1717461016464.tsv",
                                 sep = "\t", header = T))
C7_VAX.up <- sortGSEAdata(C7_VAX.up, "C7_VAX", "TB")
C7_VAX.dn <- sortGSEAdata(C7_VAX.dn, "C7_VAX", "C")


C7 <- rbind(C7_IMMUNE.up, C7_IMMUNE.dn, C7_VAX.up, C7_VAX.dn)
write.xlsx(C7, "GSEA/C7_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C7[C7$FDR_qval < 0.25, ], "GSEA/C7_filtered_(FDR<0.25).xlsx", rowNames = F, colNames = T)

######
# C8 #
######
C8.up <- data.frame(read.csv("GSEA/C8/gsea_report_for_TB_1717461452320.tsv", sep = "\t", header = T))
C8.dn <- data.frame(read.csv("GSEA/C8/gsea_report_for_Control_1717461452320.tsv", sep = "\t", header = T))
C8.up <- sortGSEAdata(C8.up, "C8", "TB")
C8.dn <- sortGSEAdata(C8.dn, "C8", "C")


C8 <- rbind(C8.up, C8.dn)
write.xlsx(C8, "GSEA/C8_full_results.xlsx", rowNames = F, colNames = T)
write.xlsx(C8[C8$FDR_qval < 0.25, ], "GSEA/C8_filtered_(FDR<0.25).xlsx", rowNames = F, colNames = T)
```

#### Balloon plots

```{r}
balloon_data <- H[H$FDR_qval < 0.25, ]

ggplot(balloon_data, aes(x = COMPARISON, y = NAME, color = NES, size = `-Log10FDR`)) +
  geom_point() +
  #scale_size_continuous(range = c(0, 1.5), breaks = c(0, 0.5, 1, 1.5)) +  # Adjust the circle size
  scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, na.value = "gray90") +
  facet_grid(COLLECTION ~ COMPARISON, space = "free", scales = "free") +
  theme_classic() +
  theme(
    axis.text.x = element_blank(),#element_text(angle = 30, hjust = 1),
    strip.background = element_rect(fill = "gray90", colour = "white", linewidth = 1),
    strip.text.x = element_text(face = "bold", size = 10),
    strip.text.y = element_text(face = "bold", size = 10, angle = 90, hjust = 0.5),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_line(linewidth = 0.2, linetype = 'solid', color = "grey90"),
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(), #element_text(face = "bold"),
    axis.title.y = element_text(face = "bold")
  ) +
  labs(size = "-Log10FDR", color = "NES", y = "PATHWAYS", x = "PHENOTYPE") +
  guides(size = guide_legend(override.aes = list(shape = 21, fill = "white", color = "black")))

# Save the revised Balloon Plot
ggsave("GSEA/H_(qval<0.25).jpg", height = 13, width = 10, dpi = 600, limitsize = FALSE)
```

# 7. Prognostic model

## Call libraries

```{r}
library("MASS", quietly = T)
library(pROC)
library(openxlsx)
library(ggplot2)
library(dplyr)
library(nortest)
library(car)
library(reshape2)
library(caret)
library(broom)
```

## Selected genes for Prognostic Model

```{r}
res <- res.TB_C.det[res.TB_C.det$padj < 0.01, ]

res_pos <- res[order(res$stat, decreasing = TRUE), ]
res_pos <- res_pos[res_pos$stat > 0, ]
y <- normalized.counts[res_pos$ensembl[1:20], ]
y <- y[y$Mean.TB > 500 & y$Mean.C < 500, ]
res_pos <- res_pos[rownames(y), ]

res_neg <- res[order(res$stat, decreasing = FALSE), ]
res_neg <- res_neg[res_neg$stat < 0, ]
y <- normalized.counts[res_neg$ensembl[1:20], ]
y <- y[y$Mean.C > 500 & y$Mean.TB < 500, ]
res_neg <- res_neg[rownames(y), ]

input_olr <- gene.tpm.annotated[c(res_pos$ensembl, res_neg$ensembl), ]

rownames(input_olr) <- input_olr$symbol
input_olr <- input_olr[, 1:19]
input_olr <- t(input_olr)
input_olr <- as.data.frame(input_olr)
input_olr$binary <- ifelse(sampledata$group == "TB", 1, 0)
input_olr$sex <- ifelse(sampledata$sex == "F", 0, 1)
input_olr <- cbind(input_olr, sampledata[, confounding_var[2:17]])
input_olr$sample <- rownames(input_olr)

# Selected genes
genes_9 <- colnames(input_olr[1:12])
input_olr <- input_olr[, c("sample", "sex", confounding_var[2:17], genes_9, "binary")]

# Write output
write.xlsx(input_olr, file = paste0("OLR/", "input_OLR_", dea_formula, ".xlsx"), asTable = FALSE)
```

## Statistical analysis

```{r}
data <- data.frame(read.xlsx("OLR/input_OLR_group.xlsx"))
clinical <- colnames(data)[2:18]

# Convert factors
data <- data %>%
  mutate(
    binary = factor(binary, levels = c(0, 1), ordered = TRUE),
    sex = factor(sex, levels = c(0, 1), ordered = TRUE),
    latent_TB = factor(latent_TB, levels = c(0, 1), ordered = TRUE),
    age_cat = factor(age_cat, levels = c("20s", "30s", "40s", "50s", "60s"), ordered = TRUE),
    HR_cat = factor(HR_cat, levels = c("60s", "70s", "80s", "90s", "100s", "140s"), ordered = TRUE),
    weight_cat = factor(weight_cat, levels = c("40s", "50s", "60s", "70s", "80s", "90s"), ordered = TRUE),
    height_cat = factor(height_cat, levels = c("140", "150", "160", "170", "180"), ordered = TRUE)
  )

data[, genes_9] <- apply(data[, genes_9], 2, function (column) {
  if (any(column == 0)) {
    column <- column + 10**-6
  }
  log2(column)
})
data[, genes_9] <- apply(data[, genes_9], 2, scale)

# Test for normality
## Perform Shapiro-Wilk Test for each gene
shapiro_results <- data.frame(
  Gene = genes_9,
  pval = sapply(data[, genes_9], function(x) shapiro.test(x)$p.value)
)

shapiro_results$significance <- ifelse(shapiro_results$pval < 0.05, "Non-Normal", "Normal")
shapiro_results

# QQ plots
for (gene in genes_9) {
  gene_data <- data[[gene]]
  n <- length(gene_data)  # Number of samples
  
  # Theoretical quantiles
  q_theoretical <- qnorm((1:n) / (n + 1))
  
  # Calculate confidence intervals
  se <- sqrt((1 / n) * (1 - (1:n) / (n + 1)))  # Standard error for order statistics
  ci_upper <- q_theoretical + qnorm(0.975) * se
  ci_lower <- q_theoretical - qnorm(0.975) * se
  
  # Prepare data for plotting
  qq_df <- data.frame(
    Observed = sort(gene_data),
    Theoretical = q_theoretical,
    CI_Upper = ci_upper,
    CI_Lower = ci_lower
  )
  
  # Generate QQ Plot with Confidence Band
  p.qq <- ggplot(qq_df, aes(x = Theoretical, y = Observed)) +
    geom_ribbon(aes(ymin = CI_Lower, ymax = CI_Upper), fill = "grey80", alpha = 0.5) + # Confidence band
    geom_point() +  # QQ points
    geom_abline(slope = 1, intercept = 0, color = "blue", linetype = "dashed") + # Reference diagonal
    theme_bw() +
    labs(
      title = gene,
      x = "Theoretical Quantiles",
      y = "Sample Quantiles"
    )
  
  print(p.qq)
  
  ggsave(filename = paste0("OLR/QQ/", gene, "_QQplot.jpg"), width = 4, height = 4, dpi = 300)
}

# Check expression distribution
## BSV plots
x <- as.data.frame(rbind(res_pos[, c("ensembl", "symbol")], res_neg[, c("ensembl", "symbol")]))
write.xlsx(x = x, file = paste0("OLR/", "initial_genes_", dea_formula, ".xlsx"), asTable = FALSE)

for (i in 1:length(x[, "ensembl"])) {
    
    # Extracting the vector of counts for that gene
    gene_counts <- counts(ds.deseq, normalized = TRUE)[x[i, "ensembl"], ]
    log2_gc <- log2(gene_counts)
    
    # Making a dataframe for the plot
    df.box <- data.frame(ds.deseq@colData[, c("id", "group", "sex",
                                              "age", "age_cat", "num")], log2_gc)
    
    # Re-ordering sample_type for the plot
    df.box$group <- factor(df.box$group,
                           levels = c("Control", "TB"),
                           labels = c("Control", "TB"))
    
    # Plot
    p.bs <- ggplot(df.box, aes(x = group, y = log2_gc)) + theme_bw() +
      
      # Violin plot
      geom_violin(scale = "count",
                  #alpha = 0,
                  fill = NA, colour = "peru",#aes(fill = gp), color = "transparent",
                  show.legend = FALSE, trim = TRUE, linewidth = 0.7) +
      
      # Box plot with error bar
      geom_boxplot(width = 0.07, fill = "gray90") +
      geom_errorbar(stat = "boxplot", width = 0.3, linewidth = 1, color = "black",
                    aes(ymin = after_stat(middle), ymax = after_stat(middle))) +
      
      # Scatter plot
      geom_point(data = df.box, aes(fill = group), shape = 21,
                 size = 5, alpha = 1, position = position_jitter(width = 0.15)) +
      
      # Axis labels
      labs(x = NULL, y = expression("log"[2]*"(Normalized Counts)"), title = paste0(x[i, "symbol"])) +
      
      # Axis text size
      theme(axis.text.x = element_text(size = 24),#angle = 70, vjust = 1, hjust = 1)
            axis.text.y = element_text(size = 16),
            axis.title.y = element_text(size = 22),
            title = element_text(size = 26)) +
      
      # Legend setting
      scale_fill_manual(name = "Group", values = c("Control" = "#bbffff", "TB" = "#ffb6c1"),
                        #guide = guide_legend(override.aes = aes(shape = 21, size = 7)),
                        guide = "none") +
      
      # Legend size
      theme(legend.title = element_text(size= 17, face = "bold"), legend.text=element_text(size = 16),
            panel.grid.major = element_line(colour = "gray80", linetype = "dashed", linewidth = 0.25),
            panel.grid.minor = element_line(colour = "gray80", linetype = "dashed", linewidth = 0.25))
    
    
    # Set max and min values without considering +/- Inf values
    min_value <- min(df.box$log2_gc[is.finite(df.box$log2_gc)])
    max_value <- max(df.box$log2_gc[is.finite(df.box$log2_gc)])
    
    # Generating y position for the significance bars
    ## Objective: maintain same proportion in distance for each plot
    y_range <- diff(range(df.box$log2_gc[is.finite(df.box$log2_gc)]))
    prop <- 0.08*y_range
    
    # Creating signif data for all genes
    sig_data <- data.frame(gene = rep(x[i, "symbol"], 1),
                           group1 = c("Control"),
                           group2 = c("TB"),
                           ypos = c(max_value + prop
                                    #max_value + prop,
                                    #max_value + prop*2.2, max_value + prop*2.2,
                                    #max_value + prop*3.4
                                    ), #otherwise multiply prop by 3 or above
                           label = c(get_stars(x[i, "ensembl"], res.TB_C)
                                     #get_stars(x[i, "ensembl"], res.Bp_Ap),
                                     #get_stars(x[i, "ensembl"], res.Bn_An),
                                     #get_stars(x[i, "ensembl"], res.Bp_Bn),
                                     #get_stars(x[i, "ensembl"], res.Bp_An)
                                     ))
    
    # Ticks by same unit
    p.bs <- p.bs + scale_y_continuous(breaks = seq(floor(min_value), ceiling(max_value), by = 1))
    p.bs <- p.bs + geom_signif(data = sig_data, manual = TRUE, size = 1.7, colour = "grey5",
                               aes(xmin = group1, xmax = group2, annotations = label, y_position = ypos),
                               textsize = 7, vjust = 0, tip_length = 0.02)
    
    print(p.bs)
    
    ggsave(filename = paste0("OLR/BSV/", x[i, "symbol"], ".jpg"), width = 6, height = 7.5, dpi = 300)
}

## Remove non-normal genes
#data <- data[, !(colnames(data) %in% shapiro_results$Gene[shapiro_results$significance == "Non-Normal"])]
#genes_9 <- genes_9[!(genes_9 %in% shapiro_results$Gene[shapiro_results$significance == "Non-Normal"])]

# Correlation
cor_matrix_9 <- cor(data[, genes_9])
melted_cor_matrix_9 <- melt(cor_matrix_9)

## Correlation matrix
ggplot(data = melted_cor_matrix_9, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = round(value, 2)), color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab", 
                       name="Pearson\nCorrelation") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 12, hjust = 1)) +
  coord_fixed()

## Remove highly correlated genes
#genes_9 <- genes_9[-findCorrelation(cor_matrix_9, cutoff = 0.95)]
genes_9 <- genes_9[-12]
data <- data[, c("sample", clinical, genes_9, "binary")]
```

## GLM with our data

```{r}
# Results data frame
model_results <- data.frame(
  Gene = character(),
  Variable = character(),
  AIC = numeric(),
  Gene_coef = numeric(),
  Var_coef = numeric(),
  Anova = numeric(),
  McFadden_R2 = numeric(),
  VIF = numeric(),
  OR = numeric(),
  Warning = logical(),
  stringsAsFactors = FALSE
)

# Baseline null model (only sex included)
null_model <- glm(binary ~ 1, data = data, family = binomial(link = "logit"))

# Evaluate model by gene
for (gene in genes_9) {
  
  formula <- as.formula(paste("binary ~ ", gene))
  
  # Initialize Warning flag
  model_warning <- FALSE
  
  # Capture warnings during model fitting
  model <- tryCatch(
    withCallingHandlers(
      glm(formula, data = data, family = binomial(link = "logit")),
      warning = function(w) {
        model_warning <<- TRUE
        invokeRestart("muffleWarning")
      }
    ),
    error = function(e) {
      model_warning <<- TRUE
      return(NULL)
    }
  )
  
  # Skip if the model failed completely
  if (is.null(model)) {
    model_results <- rbind(model_results, data.frame(
      Gene = gene,
      Variable = "None",
      AIC = NA,
      Gene_coef = NA,
      Var_coef = NA,
      Anova = NA,
      McFadden_R2 = NA,
      VIF = NA,
      OR = NA,
      Warning = TRUE
    ))
    next
  }
  
  # McFadden's R² - Proportion of explained variance
  mcfadden_r2 <- 1 - (logLik(model) / logLik(null_model))
  
  # Extract coefficients
  gene_coef <- if (gene %in% rownames(coef(summary(model)))) {
    coef(summary(model))[gene, "Pr(>|z|)"]
  } else {
    NA
  }
  
  # ANOVA
  anova_result <- Anova(model, type = "II", test = "LR")
  anova_p_value <- if (gene %in% rownames(anova_result)) {
    anova_result$`Pr(>Chisq)`[rownames(anova_result) == gene]
  } else {
    NA
  }
  
  # VIF (not applicable for models with a single predictor, set as NA)
  vif_value <- NA
  
  # Odds Ratio
  or_value <- if (gene %in% names(coef(model))) {
    exp(coef(model)[gene])
  } else {
    NA
  }
  
  # Store results
  model_results <- rbind(model_results, data.frame(
    Gene = gene,
    Variable = "None",
    AIC = AIC(model),
    Gene_coef = gene_coef,
    Var_coef = NA,
    Anova = anova_p_value,
    McFadden_R2 = mcfadden_r2,
    VIF = vif_value,
    OR = or_value,
    Warning = model_warning
  ))
}

# Evaluate model by gene + variable
for (gene in genes_9) {
  for (clinical_var in clinical) {
    
    formula <- as.formula(paste("binary ~ ", clinical_var, " + ", gene))
    
    # Initialize Warning flag
    model_warning <- FALSE
    
    # Capture warnings during model fitting
    model <- tryCatch(
      withCallingHandlers(
        glm(formula, data = data, family = binomial(link = "logit")),
        warning = function(w) {
          model_warning <<- TRUE
          invokeRestart("muffleWarning")
        }
      ),
      error = function(e) {
        model_warning <<- TRUE
        return(NULL)
      }
    )
    
    # Skip if the model failed completely
    if (is.null(model)) {
      model_results <- rbind(model_results, data.frame(
        Gene = gene,
        Variable = clinical_var,
        AIC = NA,
        Gene_coef = NA,
        Var_coef = NA,
        Anova = NA,
        McFadden_R2 = NA,
        VIF = NA,
        OR = NA,
        Warning = TRUE
      ))
      next
    }
    
    # McFadden's R² - Proportion of explained variance
    mcfadden_r2 <- 1 - (logLik(model) / logLik(null_model))
    
    # Extract coefficients
    gene_coef <- if (gene %in% rownames(coef(summary(model)))) {
      coef(summary(model))[gene, "Pr(>|z|)"]
    } else {
      NA
    }
    
    var_coef <- if (clinical_var %in% rownames(coef(summary(model)))) {
      coef(summary(model))[clinical_var, "Pr(>|z|)"]
    } else {
      NA
    }
    
    # ANOVA
    anova_result <- Anova(model, type = "II", test = "LR")
    anova_p_value <- if (gene %in% rownames(anova_result)) {
      anova_result$`Pr(>Chisq)`[rownames(anova_result) == gene]
    } else {
      NA
    }
    
    # VIF
    vif_value <- if (gene %in% names(vif(model))) {
      vif(model)[gene]
    } else {
      NA
    }
    
    # Odds Ratio
    or_value <- if (gene %in% names(coef(model))) {
      exp(coef(model)[gene])
    } else {
      NA
    }
    
    # Store results
    model_results <- rbind(model_results, data.frame(
      Gene = gene,
      Variable = clinical_var,
      AIC = AIC(model),
      Gene_coef = gene_coef,
      Var_coef = var_coef,
      Anova = anova_p_value,
      McFadden_R2 = mcfadden_r2,
      VIF = vif_value,
      OR = or_value,
      Warning = model_warning
    ))
  }
}

# Order results: Models without warnings first, then by AIC
model_results <- model_results %>%
  arrange(Warning, AIC)

# Print the results
print(model_results)

# Save results
write.xlsx(x = model_results, file = paste0("OLR/model_results_", dea_formula, ".xlsx"))

# --- Final model --- #
#final_model <- glm(binary ~ VCAN, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ CTSB, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ sex + VCAN, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ sex + CTSB, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ age + VCAN, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ age + CTSB, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ age + sex + VCAN, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ age + sex + CTSB, data = data, family = binomial(link = "logit"))
final_model <- glm(binary ~ sex + CTSB + VCAN, data = data, family = binomial(link = "logit")) #!!!
#final_model <- glm(binary ~ age + CTSB + VCAN, data = data, family = binomial(link = "logit"))
#final_model <- glm(binary ~ age + sex + CTSB + VCAN, data = data, family = binomial(link = "logit"))

summary(final_model)
print(Anova(final_model))
AIC(final_model)
1 - (logLik(final_model) / logLik(null_model))
vif(final_model)
exp(coef(final_model))
```

## Exploration with our dataset

```{r}
predicted_probs <- predict(final_model, type = "response") # For glm
predicted_probs

names(predicted_probs) <- c(rep("TB", 10), rep("Control", 9))

# Plotting ROC
roc_TB_C <- roc(data$binary, predicted_probs)
roc_TB_C.df <- data.frame(
  specificity = rev(roc_TB_C$specificities),
  sensitivity = rev(roc_TB_C$sensitivities),
  dset = "Guevara"
)

roc_TB_C.df$xvalue <- 1 - roc_TB_C.df$specificity
auc(roc_TB_C)

# Create the ROC plot

roc_label <- data.frame(xaxis = 0.75,
                        yaxis = 0.1,
                        value = paste("AUC = ", round(as.numeric(auc(roc_TB_C)), 3))
                        )

roc_plot <- ggplot(roc_TB_C.df, aes(x = xvalue, y = sensitivity , color = dset)) +
  
  # ROC curve
  geom_line(linewidth = 1.5,
            show.legend = TRUE) +
  
  # Shaded area
  geom_ribbon(aes(ymin = 0, ymax = sensitivity), fill = alpha("red1", 0.05), color = NA) +
  
  # Diagonal
  geom_segment(x = 0, y = 0, xend = 1, yend = 1,
               linetype = "dashed", color = "blue1", linewidth = 1) +
  
  scale_x_continuous(name = "False Positive Rate", limits = c(0, 1), breaks = seq(0, 1, by = 0.2), expand = c(0.01, 0.01)) +
  scale_y_continuous(name = "True Positive Rate", limits = c(0, 1), breaks = seq(0, 1, by = 0.2), expand = c(0.01, 0.01)) +
  scale_color_manual(name = "Comparison",
                     values = "red1",
                     breaks = c("Guevara"),
                     labels = c(paste0("TB vs Control"))) +
  
  ggtitle("Exploration") +
  
  geom_label(data = roc_label, aes(x = xaxis, y = yaxis, label = value),
             color = "black", fill = "white", label.size = 0.5, size = 7,
             label.padding = unit(0.05, "lines")) +
  
  theme_minimal() +
  theme(plot.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
        legend.position = "right",
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 16, face = "bold")
        )

roc_plot

ggsave(filename = paste0("OLR/ROC/roc_plot_",
                         paste(attr(terms(final_model$formula), "term.labels"), collapse = "_"),
                         ".jpg"), width = 7.3, height = 5, dpi = 300)
```


### Data for Danni
```{r}
#data <- data.frame(read.xlsx("GSEA/Data_processed/GSEA_curated.xlsx"))
#write.table(data, file = "GSEA/Data_processed/GSEA_curated.tsv", sep = "\t")
```






